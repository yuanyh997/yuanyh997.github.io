<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 基本知识（3）]]></title>
    <url>%2F2019%2F04%2F03%2FJava-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java 基本知识（3）十二、封装的作用和意义需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。说的专业一点，封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 123我们程序设计要追求“高内聚，低耦合”。 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。 编程中封装的具体优点 提高代码的安全性。 提高代码的复用性。 “高内聚”：封装细节，便于修改内部代码，提高可维护性。 “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。 封装的实现—使用访问控制符 Java是使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露的。 Java中4种“访问控制符”分别为private、default、protected、public，它们说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性。 表 访问权限修饰符 private 表示私有，只有自己类能访问 default表示没有修饰符修饰，只有同一个包的类能访问 protected表示可以被同一个包的类以及其他包中的子类访问 public表示可以被该项目的所有包中的所有类访问 下面做进一步说明Java中4种访问权限修饰符的区别：首先我们创建4个类：Person类、Student类、Animal类和Computer类，分别比较本类、本包、子类、其他包的区别。 类的属性的处理 一般使用private访问权限。 提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 十三、多态多态的要点 多态是方法的多态，不是属性的多态(多态与属性无关)。 多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了 十四、变量的转型 父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。 向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型! 十五、final关键字的作用修饰变量被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。 1final int MAX_SPEED = 120; 修饰方法该方法不可被子类重写。但是可以被重载! 123final void study()&#123; &#125; 修饰类修饰的类不能被继承。比如：Math、String等。 123final class A &#123; &#125; 十六、抽象方法抽象类抽象方法使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。 抽象类包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 【示例】抽象类和抽象方法的基本用法 123456789101112131415161718192021//抽象类abstract class Animal &#123; abstract public void shout(); //抽象方法&#125;class Dog extends Animal &#123; //子类必须实现父类的抽象方法，否则编译错误 public void shout() &#123; System.out.println("汪汪汪！"); &#125; public void seeDoor()&#123; System.out.println("看门中...."); &#125;&#125;//测试抽象类public class TestAbstractClass &#123; public static void main(String[] args) &#123; Dog a = new Dog(); a.shout(); a.seeDoor(); &#125;&#125; 抽象类的使用要点 有抽象方法的类只能定义成抽象类 抽象类不能实例化，即不能用new来实例化抽象类。 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 抽象类只能用来被继承。 抽象方法必须被子类实现。 十七、接口的定义和使用声明格式1234[访问修饰符] interface 接口名 [extends 父接口1，父接口2…] &#123; 常量定义； 方法定义；&#125; 定义接口的详细说明 访问修饰符：只能是public或默认。 接口名：和类名采用相同命名机制。 extends：接口可以多继承。 常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。 方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。 要点 子类通过implements来实现接口中的规范。 接口不能创建实例，但是可用于声明引用变量类型。 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。 JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。 JDK1.8后，接口中包含普通的静态方法。 接口的使用1234567891011121314151617181920212223242526272829303132333435363738public class TestInterface &#123; public static void main(String[] args) &#123; Volant volant = new Angel(); volant.fly(); System.out.println(Volant.FLY_HIGHT); Honest honest = new GoodMan(); honest.helpOther(); &#125;&#125;/**飞行接口*/interface Volant &#123; int FLY_HIGHT = 100; // 总是：public static final类型的； void fly(); //总是：public abstract void fly();&#125;/**善良接口*/interface Honest &#123; void helpOther();&#125;/**Angle类实现飞行接口和善良接口*/class Angel implements Volant, Honest&#123; public void fly() &#123; System.out.println("我是天使，飞起来啦！"); &#125; public void helpOther() &#123; System.out.println("扶老奶奶过马路！"); &#125;&#125;class GoodMan implements Honest &#123; public void helpOther() &#123; System.out.println("扶老奶奶过马路！"); &#125; &#125;class BirdMan implements Volant &#123; public void fly() &#123; System.out.println("我是鸟人，正在飞！"); &#125;&#125; 接口支持多继承，和类的继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切。 接口的多继承123456789101112131415161718interface A &#123; void testa();&#125;interface B &#123; void testb();&#125;/**接口可以多继承：接口C继承接口A和B*/interface C extends A, B &#123; void testc();&#125;public class Test implements C &#123; public void testc() &#123; &#125; public void testa() &#123; &#125; public void testb() &#123; &#125;&#125; 十八、内部类内部类的概念 一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(inner classes)。 内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰。 注意内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同。 内部类介绍123456789101112131415/**外部类Outer*/class Outer &#123; private int age = 10; public void show()&#123; System.out.println(age);//10 &#125; /**内部类Inner*/ public class Inner &#123; //内部类中可以声明与外部类同名的属性与方法 private int age = 20; public void show()&#123; System.out.println(age);//20 &#125; &#125;&#125; 内部类的作用 内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。 内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。 接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。 内部类的使用场合 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。 使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。 内部类的分类 在Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。 成员内部类(可以使用private、default、protected、public任意进行修饰。 类文件：外部类$内部类.class) a) 非静态内部类外部类里使用非静态内部类和平时使用其他类没什么不同 i. 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。 ii. 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。 iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。 iv. 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。 v. 成员变量访问要点： 内部类里方法的局部变量：变量名。 内部类属性：this.变量名。 外部类属性：外部类名.this.变量名。 【举例】123456789101112class Outer &#123; private int age = 10; class Inner &#123; int age = 20; public void show() &#123; int age = 30; System.out.println("内部类方法里的局部变量age:" + age);// 30 System.out.println("内部类的成员变量age:" + this.age);// 20 System.out.println("外部类的成员变量age:" + Outer.this.age);// 10 &#125; &#125;&#125; vi. 内部类的访问： 外部类中定义内部类： 1new Inner() 外部类以外的地方使用非静态内部类： 1Outer.Inner varname = new Outer().new Inner()。 内部类的访问 12345678910public class TestInnerClass &#123; public static void main(String[] args) &#123; //先创建外部类实例，然后使用该外部类实例创建内部类实例 Outer.Inner inner = new Outer().new Inner(); inner.show(); Outer outer = new Outer(); Outer.Inner inn = outer.new Inner(); inn.show(); &#125;&#125; b) 静态内部类i. 定义方式：123static class ClassName &#123;//类体&#125; ii. 使用要点：1231. 当一个静态内部类对象存在，并不一定存在对应的外部类对象。 因此，静态内部类的实例方法不能直接访问外部类的实例方法。2. 静态内部类看做外部类的一个静态成员。 因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过 new 静态内部类()访问静态内部类的实例。 静态内部类的访问123456789101112class Outer&#123; //相当于外部类的一个静态成员 static class Inner&#123; &#125;&#125;public class TestStaticInnerClass &#123; public static void main(String[] args) &#123; //通过 new 外部类名.内部类名() 来创建内部类对象 Outer.Inner inner =new Outer.Inner(); //Outer.Inner inner = new Outer().new Inner(); 非静态内部类 &#125;&#125; 匿名内部类1适合那种只需要使用一次的类。比如：键盘监听操作等等。 语法123new 父类构造器(实参类表) \实现接口 () &#123; //匿名内部类类体！&#125; 匿名内部类的使用123456789101112131415161718this.addWindowListener(new WindowAdapter()&#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;);this.addKeyListener(new KeyAdapter()&#123; @Override public void keyPressed(KeyEvent e) &#123; myTank.keyPressed(e); &#125; @Override public void keyReleased(KeyEvent e) &#123; myTank.keyReleased(e); &#125; &#125;); 注意 匿名内部类没有访问修饰符。 匿名内部类没有构造方法。因为它连名字都没有那又何来构造方法呢。 局部内部类还有一种内部类，它是定义在方法内部的，作用域只限于本方法，称为局部内部类。 局部内部类的的使用主要是用来解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类。局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法中被使用，出了该方法就会失效。 局部内部类在实际开发中应用很少。 方法中的内部类1234567891011121314public class Test2 &#123; public void show() &#123; //作用域仅限于该方法 class Inner &#123; public void fun() &#123; System.out.println("helloworld"); &#125; &#125; new Inner().fun(); &#125; public static void main(String[] args) &#123; new Test2().show(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基本知识（2）]]></title>
    <url>%2F2019%2F04%2F03%2FJava-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java 基本知识（2）七、this关键字对象创建的过程和this的本质 构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步： 分配对象空间，并将对象成员变量初始化为0或空 执行属性值的显示初始化 执行构造方法 返回对象的地址给相关的变量 this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。 this最常的用法 在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。 this不能用于static方法中。 this代表“当前对象”示例1234567891011121314151617181920`public class User &#123; int id; //id String name; //账户名 String pwd; //密码 public User() &#123; &#125; public User(int id, String name) &#123; System.out.println("正在初始化已经创建好的对象："+this); this.id = id; //不写this，无法区分局部变量id和成员变量id this.name = name; &#125; public void login()&#123; System.out.println(this.name+",要登录！"); //不写this效果一样 &#125; public static void main(String[] args) &#123; User u3 = new User(101,"高小七"); System.out.println("打印高小七对象："+u3); u3.login(); &#125; &#125; 运行结果如图所示。 this()调用重载构造方法1234567891011121314151617181920212223242526272829public class TestThis &#123; int a, b, c; TestThis() &#123; System.out.println("正要初始化一个Hello对象"); &#125; TestThis(int a, int b) &#123; // TestThis(); //这样是无法调用构造方法的！ this(); // 调用无参的构造方法，并且必须位于第一行！ a = a;// 这里都是指的局部变量而不是成员变量 // 这样就区分了成员变量和局部变量. 这种情况占了this使用情况大多数 this.a = a; this.b = b; &#125; TestThis(int a, int b, int c) &#123; this(a, b); // 调用带参的构造方法，并且必须位于第一行！ this.c = c; &#125; void sing() &#123; &#125; void eat() &#123; this.sing(); // 调用本类中的sing(); System.out.println("你妈妈喊你回家吃饭！"); &#125; public static void main(String[] args) &#123; TestThis hi = new TestThis(2, 3); hi.eat(); &#125;&#125; 八、static关键字特点在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点： 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!! 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。) 在static方法中不可直接访问非static的成员。 核心要点： static修饰的成员变量和方法，从属于类。 普通变量和方法从属于对象的。 12345678910111213141516171819202122232425262728293031public class User2 &#123; int id; // id String name; // 账户名 String pwd; // 密码 static String company = "北京尚学堂"; // 公司名称 public User2(int id, String name) &#123; this.id = id; this.name = name; &#125; public void login() &#123; printCompany(); System.out.println(company); System.out.println("登录：" + name); &#125; public static void printCompany() &#123;// login();//调用非静态成员，编译就会报错 System.out.println(company); &#125; public static void main(String[] args) &#123; User2 u = new User2(101, "高小七"); User2.printCompany(); User2.company = "北京阿里爷爷"; User2.printCompany(); &#125;&#125; 静态初始化块构造方法用于对象的初始化!静态初始化块，用于类的初始化操作!在静态初始化块中不能直接访问非static成员。 注意事项： 静态初始化块执行顺序： 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。 构造方法执行顺序和上面顺序一样!! static初始化块 1234567891011121314151617public class User3 &#123; int id; //id String name; //账户名 String pwd; //密码 static String company; //公司名称 static &#123; System.out.println("执行类的初始化工作"); company = "北京尚学堂"; printCompany(); &#125; public static void printCompany()&#123; System.out.println(company); &#125; public static void main(String[] args) &#123; User3 u3 = new User3(); &#125;&#125; 九、参数传值机制 Java中，方法中所有参数都是“值传递”，也就是“传递的是值的副本”。 也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件改变不会影响原件。 基本数据类型参数的传值 传递的是值的副本。 副本改变不会影响原件。 引用类型参数的传值 传递的是值的副本。但是引用类型指的是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”。 多个变量指向同一个对象1234567891011121314151617181920212223242526public class User4 &#123; int id; //id String name; //账户名 String pwd; //密码 public User4(int id, String name) &#123; this.id = id; this.name = name; &#125; public void testParameterTransfer01(User4 u)&#123; u.name="高小八"; &#125; public void testParameterTransfer02(User4 u)&#123; u = new User4(200,"高三"); &#125; public static void main(String[] args) &#123; User4 u1 = new User4(100, "高小七"); u1.testParameterTransfer01(u1); System.out.println(u1.name); u1.testParameterTransfer02(u1); System.out.println(u1.name); 十、包包机制是Java中管理类的重要手段。 开发中，我们会遇到大量同名的类，通过包我们很容易对解决类重名的问题，也可以实现对类的有效管理。 包对于类，相当于文件夹对于文件的作用。 包的使用我们通过package实现对类的管理，package的使用有两个要点： 通常是类的第一句非注释性语句。 包名：域名倒着写即可，再加上模块名，便于内部管理类。 【示例】 package的命名举例 12345com.sun.test;com.oracle.test;cn.sxt.yuan.test;cn.sxt.yuan.view;cn.sxt.yuan.view.model; 注意事项： 写项目时都要加包，不要使用默认包。 com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分。 【示例】package的使用 123456package cn.yuan;public class Test &#123; public static void main(String[] args) &#123; System.out.println("helloworld"); &#125;&#125; Java中常用包 Java中的常用包 说明 java.lang 包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。 java.awt 包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 java.net 包含执行与网络相关的操作的类。 java.io 包含能提供多种输入/输出功能的类。 java.util 包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。 如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性。 注意要点： Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。 如果导入两个同名的类，只能用包名+类名来显示调用相关类： 1java.util.Date date = new java.util.Date(); 【示例】1234567891011121314import java.sql.Date;import java.util.*;//导入该包下所有的类。会降低编译速度，但不会降低运行速度。 public class Test&#123; public static void main(String[] args) &#123; //这里指的是java.sql.Date Date now; //java.util.Date因为和java.sql.Date类同名，需要完整路径 java.util.Date now2 = new java.util.Date(); System.out.println(now2); //java.util包的非同名类不需要完整路径 Scanner input = new Scanner(System.in); &#125;&#125; 十一、继承继承的实现1234567891011121314151617181920212223242526public class Test&#123; public static void main(String[] args) &#123; Student s = new Student("高淇",172,"Java"); s.rest(); s.study(); &#125;&#125;class Person &#123; String name; int height; public void rest()&#123; System.out.println("休息一会！"); &#125; &#125;class Student extends Person &#123; String major; //专业 public void study()&#123; System.out.println("在尚学堂，学习Java"); &#125; public Student(String name,int height,String major) &#123; //天然拥有父类的属性 this.name = name; this.height = height; this.major = major; &#125;&#125; 继承的使用要点1.父类也称作超类、基类等。 2.Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。 3.Java中类没有多继承，接口有多继承。 4.子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。 5.如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。 方法的重写override方法重写的三个要点123451.“==”： 方法名、形参列表相同。2.“≤”：返回值类型和声明异常类型，子类小于等于父类。3.“≥”： 访问权限，子类大于等于父类。 【示例】方法重写1234567891011121314151617181920212223242526272829303132333435public class TestOverride &#123; public static void main(String[] args) &#123; Vehicle v1 = new Vehicle(); Vehicle v2 = new Horse(); Vehicle v3 = new Plane(); v1.run(); v2.run(); v3.run(); v2.stop(); v3.stop(); &#125;&#125; class Vehicle &#123; // 交通工具类 public void run() &#123; System.out.println("跑...."); &#125; public void stop() &#123; System.out.println("停止不动"); &#125;&#125;class Horse extends Vehicle &#123; // 马也是交通工具 public void run() &#123; // 重写父类方法 System.out.println("四蹄翻飞，嘚嘚嘚..."); &#125;&#125; class Plane extends Vehicle &#123; public void run() &#123; // 重写父类方法 System.out.println("天上飞！"); &#125; public void stop() &#123; System.out.println("空中不能停，坠毁了！"); &#125;&#125; super关键字 super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。 123使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。若是构造方法的第一行代码没有显式的调用super(...)或者this(...);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。 super关键字的使用12345678910111213141516171819202122public class TestSuper01 &#123; public static void main(String[] args) &#123; new ChildClass().f(); &#125;&#125;class FatherClass &#123; public int value; public void f()&#123; value = 100; System.out.println ("FatherClass.value="+value); &#125;&#125;class ChildClass extends FatherClass &#123; public int value; public void f() &#123; super.f(); //调用父类对象的普通方法 value = 200; System.out.println("ChildClass.value="+value); System.out.println(value); System.out.println(super.value); //调用父类对象的成员变量 &#125;&#125; 继承树追溯属性/方法查找顺序：(比如：查找变量h)12345671. 查找当前类中有没有属性h2. 依次上溯每个父类，查看每个父类中是否有h，直到Object3. 如果没找到，则出现编译错误。4. 上面步骤，只要找到h变量，则这个过程终止。 构造方法调用顺序构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。 注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复。 构造方法向上追溯执行测试12345678910111213141516public class TestSuper02 &#123; public static void main(String[] args) &#123; System.out.println("开始创建一个ChildClass对象......"); new ChildClass(); &#125;&#125;class FatherClass &#123; public FatherClass() &#123; System.out.println("创建FatherClass"); &#125;&#125;class ChildClass extends FatherClass &#123; public ChildClass() &#123; System.out.println("创建ChildClass"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基本知识（1）]]></title>
    <url>%2F2019%2F04%2F03%2FJava-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java 基本知识（1）一、数据类型Java支持的类型分为两类：基本类型和引用类型 1.基本类型4类8种： （1）整型:int、short、long、byte。 （2）浮点型:float、double。 （3）字符型：char。 （4）布尔型：boolean。 2.引用类型引用类型包括类、接口、枚举和数组类型、null类型。 空引用null只能被被转化为引用类型，不能转化成基本类型，因此，不能把一个null值赋给基本类型的变量。 备注：（1）字符串类型是一个类，即引用类型 二、循环用法if的用法123456789if(statement)&#123; &#125;else if()&#123; &#125;else &#123; &#125; switch的用法12345678910switch (表达式) &#123; case 值1: 语句序列1; [break]; case 值2: 语句序列2; [break]; … … … … … [default:默认语句;] &#125; while和for的用法12345678while(statement)&#123; &#125;for (初始表达式; 布尔表达式; 迭代因子) &#123; 循环体; &#125; 三、重载构成方法重载的条件： 1.不同的含义：形参类型、形参个数、形参顺序不同 2.只有返回值不同不构成方法的重载 3.只有形参的名称不同，不构成方法的重载 四、面向对象和面向过程的总结 1、都是解决问题的思维方式，都是代码组织的方式。 2、解决简单问题可以使用面向过程 3、解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。 面向对象思考方式 遇到复杂问题，先从问题中找名词，然后确立这些名词哪些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。 建议 1.面向对象具有三大特征：封装性、继承性和多态性，而面向过程没有继承性和多态性，并且面向过程的封装只是封装功能，而面向对象可以封装数据和功能。所以面向对象优势更明显。 2.一个经典的比喻：面向对象是盖浇饭、面向过程是蛋炒饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。 五、栈与堆栈的特点 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 栈属于线程私有，不能实现线程间的共享! 栈的存储特性是“先进后出，后进先出” 栈是由系统自动分配，速度快!栈是一个连续的内存空间! 堆的特点 堆用于存储创建好的对象和数组(数组也是对象) JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢! 方法区(又叫静态区)特点 JVM只有一个方法区，被所有线程共享! 方法区实际也是堆，只是用于存储类、常量相关的信息! 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等) 通过new关键字调用!! 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加! 构造器的方法名必须和类名一致! 六、内存管理与GC内存管理 Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。 对象空间的分配：使用new关键字创建对象即可 对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。 垃圾回收过程任何一种垃圾回收算法一般要做两件基本事情： 发现无用的对象 回收无用对象占用的内存空间。 垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的就是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。 垃圾回收相关算法引用计数法 堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。 【示例4-7】循环引用示例 123456789101112public class Student &#123; String name; Student friend; public static void main(String[] args) &#123; Student s1 = new Student(); Student s2 = new Student(); s1.friend = s2; s2.friend = s1; s1 = null; s2 = null; &#125;&#125; s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。 引用可达法(根搜索算法) 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 分代垃圾回收机制分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。 年轻代 所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。 年老代 在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。 持久代 用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。 垃圾回收方案Minor GC: 用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空) Major GC： 用于清理老年代区域。 Full GC： 用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。 垃圾回收过程1、新创建的对象，绝大多数都会存储在Eden中， 2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区 3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。 4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中， 5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC） 在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC： 1.年老代(Tenured)被写满 2.持久代(Perm)被写满 3.System.gc()被显式调用（程序建议GC启动，不是调用GC） 4.上一次GC之后Heap的各域分配策略动态变化]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
