<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F27%2F%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[外部排序​ 给你一个包含20亿个int类型整数的文件，计算机的内存只有2GB，怎么给它们排序？一个int数占4个字节，20个亿需要80亿字节，大概占用8GB的内存，而计算机只有2GB的内存，数据都装不下！可以把8GB分割成4个2GB的数据来排，然后在把他们拼凑回去。如下图： 排序的时候我们可以选择快速排序或归并排序等算法。为了方便，我们把排序好的2G有序数据称之为有序子串吧。接着我们可以把两个小的有序子串合并成一个大的有序子串。 注意：读取的时候是每次读取一个int数，通过比较之后在输出。 按照这个方法来回合并，总共经过三次合并之后就可以得到8G的有序子串。 下面是一个具体事例：一共有12个无序数据，但是内存只能装下3个int数据 接下来把12个数据分成4份，然后排序成有序子串 然后把子串进行两两合并 输出哪个元素，就在那个元素所在的有序子串再次读入一个元素 继续 重复直到合并成一个包含6个int的有序子串 再把两个包含6个int的有序子串合并成一个包含12个int数据的最终有序子串 优化策略 因为硬盘的读写速度比内存要慢的多，按照以上这种方法，每个数据都从硬盘读了三次，写了三次，要花很多时间。 解释下：例如对于数据2，我们把无序的12个数据分成有序的4个子串需要读写各一次，把2份3个有序子串合并成6个有序子串读写各一次；把2份6个有序子串合并从12个有序子串读写各一次，一共需要读写各3次。 在进行有序子串合并的时候，不采取两两合并的方法，而是可以3个子串，或4个子串一起来合并。 多路归并为了方便讲解，我们假设内存一共可以装4个int型数据。 刚才我们是采取两两合并的方式，现在我们可以采取4个有序子串一起合并的方式，这样的话，每个数据从硬盘读写的次数各需要2次就可以了。如图： 4个有序子串的合并，叫4路归并。如果是n个有序子串的合并，就把它称为n路归并。n并非越大越好。因为n越大的确可以减少磁盘IO次数，但是相应的合并期间在内存中选取最小值的时间也会相应增加 置换选择​ n不是越大越好，那么我们可以想办法减少有序子串的总个数。这样，也能减少数据从硬盘读写的次数。 ​ 以前面的12个无序数据为例： ​ 例如我们可以从12个数据读取3个存到内存中，然后从内存中选出最小的那个数放进子串p1里；之后再从剩余的9个数据读取一个放到内存中，然后再从内存中选出一个数放进子串p1里，这个数必须满足比 p1中的其他数大，且在内存中尽量小。这样一直重复，直到内存中的数都比p1中的数小，这时p1子串存放结束，继续来p2子串的存放，例如（这时假设内存只能存放3个int型数据）： ​ 读入3个到内存中，且选出一个最小的到子串p1： ​ 从内存中再次读取一个元素86： ​ 从内存中再次读取一个元素3： ​ 从内存中再次读取一个元素24： ​ 从内存中再次读取一个元素8： ​ 这个时候已经没有符合要求的数了，且内存已满，进而用p2子串来存放，以此类推。 通过这种方法，p1子串存放了4个数据，而原来的那种方法p1子串只能存放3个数据。 利用堆排序优化查找速度从12个数据中读取3个数据，构建成一个最小堆，然后从堆顶选择一个数写入到p1中。 之后再从剩余的9个数中读取一个数，如果这个数比刚才那个写入到p1中的数大，则把这个数插入到最小堆中，重新调整最小堆结构，然后在堆顶选一个数写入到p1中。 否则，把这个数暂放在一边，暂时不处理。之后一样需要调整堆结构，从堆顶选择一个数写入到p1中。 这里说明一下，那被放在一边的数是不能再放入p1中的了，因为它一定比p1中的数都要小，所以它会放在下一个子串中 看这些文字会让人头大，我画图解释下吧。 从12数据读取3个数据 构建最小堆，且选出目标数 读入下一个数86 读入下一个数3，比70小，暂放一边，不加入堆结构中 读入下一个数据24，比81小，不加入堆结构 读入下一个数据8，比86小，不加入堆结构。此时p1已经完成了，把那些刚才暂放一边的数重新构成一个堆，继续p2的存放。 以此类推… 最后生成的p2如下： 这样子的话，最后只生成了2个有序子串，我们把这种方法称之为置换选择。按照这种方法，最好的情况下，所有数据只生成一个有序子串；最坏的情况下，和原来没采取置换选择算法一样，还是4个子串，那平均性能如何呢？ 结论：如果内存可以容纳n个元素的话，那么平均每个子串的长度为2n，也就是说，使用置换选择算法我们可以减少一半的子串数。 这种方法适合要排序的数据太多，以至于内存一次性装载不下。只能通过把数据分几次的方式来排序，把这种方法称为外部排序。 提升外部排序性能的方法 并行计算 用多个磁盘驱动器并行处理数据，可以加速顺序磁盘读写。 在计算机上使用多线程，可在多核心的计算机上得到优化。 使用异步输入输出，可以同时排序和归并，同时读写。 使用多台计算机用高速网络连接，分担计算任务。 提高硬件速度 增大内存，减小磁盘读写次数，减小归并次数。 使用快速的外存设备，比如15000 RPM的硬盘或固态硬盘。 使用性能更优良个各种设备，比如使用多核心CPU和延迟时间更短的内存。 提高软件速度 对于某些特殊数据，在第一阶段的排序中使用基数排序。 压缩输入输出文件和临时文件。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F27%2F%E7%94%A8sqlcipher%E6%9F%A5%E7%9C%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[用sqlcipher查看微信聊天记录 首先当然是先找到自己的聊天记录了，这里我用的是Root过安卓手机能获得查看权限了 路径一般是/data/data/com.tencent.mm/一串长字符串（这个也是系统自动生成的）/EnMicroMsg.db 把这个文件放到其他电脑可访问到的地址然后拷贝到电脑。 由于数据库已经加密，所以需要破解数据库的密码，百度之后发现各种软件，眼花缭乱，最后发现其实加密方式比较简单就是利用auth_info_key_prefs.xml里的auth_uin的值加上手机的IMEI码做一个md5(imei + uin)运算得到。 于是接下来查看/data/data/com.tencent.mm/shared_prefs/auth_info_key_prefs.xml文件得到uin。 在手机拨号界面输入#*06#获取IMEI码，有些有两个所以都记下备用。 得到这两个字符串之后用Python写一个小程序计算下，用得到结果的前7位作为数据库的密码。 12345678910111213import hashlib #替换成自己的uins = "402811235"#替换成自己的IMEIc1 = "862561039582893"c2 = "862561039582885"m2 = hashlib.md5()#可能出现编码问题需要转码m2.update((c1+s).encode('utf-8'))print(m2.hexdigest())m3 = hashlib.md5() m3.update((c2+s).encode('utf-8')) print(m3.hexdigest()) 取前七位为自己微信数据库的密码（字母必须为小写） 接下来下载 sqlcipher.exe 作为读取数据库的软件 将db文件拖入然后输入上一步得到的密码，就可以查看聊天记录了。 如果有其他需求可以将数据库或者对应的表导出成csv格式导入其他数据库 （注：消息在message表中）]]></content>
  </entry>
  <entry>
    <title><![CDATA[strings 包中的函数和方法]]></title>
    <url>%2F2019%2F05%2F22%2Fstrings%20%E5%8C%85%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[strings 包中的函数和方法// strings.go -———————————————————– // Count 计算字符串 sep 在 s 中的非重叠个数// 如果 sep 为空字符串，则返回 s 中的字符(非字节)个数 + 1// 使用 Rabin-Karp 算法实现123456789//func Count(s, sep string) int func main() &#123; s := "Hello,世界!!!!!" n := strings.Count(s, "!") fmt.Println(n) // 5 n = strings.Count(s, "!!") fmt.Println(n) // 2&#125;// Contains 判断字符串 s 中是否包含子串 substr// 如果 substr 为空，则返回 true1234567891011//func Contains(s, substr string) boolfunc main() &#123; s := "Hello,世界!!!!!" b := strings.Contains(s, "!!") fmt.Println(b) // true b = strings.Contains(s, "!?") fmt.Println(b) // false b = strings.Contains(s, "") fmt.Println(b) // true&#125;// ContainsAny 判断字符串 s 中是否包含 chars 中的任何一个字符// 如果 chars 为空，则返回 false1234567891011//func ContainsAny(s, chars string) boolfunc main() &#123; s := "Hello,世界!" b := strings.ContainsAny(s, "abc") fmt.Println(b) // false b = strings.ContainsAny(s, "def") fmt.Println(b) // true b = strings.Contains(s, "") fmt.Println(b) // true&#125;// ContainsRune 判断字符串 s 中是否包含字符 r 1234567891011//func ContainsRune(s string, r rune) boolfunc main() &#123; s := "Hello,世界!" b := strings.ContainsRune(s, '\n') fmt.Println(b) // false b = strings.ContainsRune(s, '界') fmt.Println(b) // true b = strings.ContainsRune(s, 0) fmt.Println(b) // false&#125; // Index 返回子串 sep 在字符串 s 中第一次出现的位置// 如果找不到，则返回 -1，如果 sep 为空，则返回 0。// 使用 Rabin-Karp 算法实现1234567891011//func Index(s, sep string) intfunc main() &#123; s := "Hello,世界!" i := strings.Index(s, "h") fmt.Println(i) // -1 i = strings.Index(s, "!") fmt.Println(i) // 12 i = strings.Index(s, "") fmt.Println(i) // 0&#125;// LastIndex 返回子串 sep 在字符串 s 中最后一次出现的位置// 如果找不到，则返回 -1，如果 sep 为空，则返回字符串的长度// 使用朴素字符串比较算法实现1234567891011//func LastIndex(s, sep string) intfunc main() &#123; s := "Hello,世界! Hello!" i := strings.LastIndex(s, "h") fmt.Println(i) // -1 i = strings.LastIndex(s, "H") fmt.Println(i) // 14 i = strings.LastIndex(s, "") fmt.Println(i) // 20&#125;// IndexRune 返回字符 r 在字符串 s 中第一次出现的位置// 如果找不到，则返回 -11234567891011//func IndexRune(s string, r rune) intfunc main() &#123; s := "Hello,世界! Hello!" i := strings.IndexRune(s, '\n') fmt.Println(i) // -1 i = strings.IndexRune(s, '界') fmt.Println(i) // 9 i = strings.IndexRune(s, 0) fmt.Println(i) // -1&#125;// IndexAny 返回字符串 chars 中的任何一个字符在字符串 s 中第一次出现的位置// 如果找不到，则返回 -1，如果 chars 为空，则返回 -11234567891011//func IndexAny(s, chars string) intfunc main() &#123; s := "Hello,世界! Hello!" i := strings.IndexAny(s, "abc") fmt.Println(i) // -1 i = strings.IndexAny(s, "dof") fmt.Println(i) // 1 i = strings.IndexAny(s, "") fmt.Println(i) // -1&#125;// LastIndexAny 返回字符串 chars 中的任何一个字符在字符串 s 中最后一次出现的位置// 如果找不到，则返回 -1，如果 chars 为空，也返回 -11234567891011//func LastIndexAny(s, chars string) intfunc main() &#123; s := "Hello,世界! Hello!" i := strings.LastIndexAny(s, "abc") fmt.Println(i) // -1 i = strings.LastIndexAny(s, "def") fmt.Println(i) // 15 i = strings.LastIndexAny(s, "") fmt.Println(i) // -1&#125;// SplitN 以 sep 为分隔符，将 s 切分成多个子串，结果中不包含 sep 本身// 如果 sep 为空，则将 s 切分成 Unicode 字符列表。// 如果 s 中没有 sep 子串，则将整个 s 作为 []string 的第一个元素返回// 参数 n 表示最多切分出几个子串，超出的部分将不再切分。// 如果 n 为 0，则返回 nil，如果 n 小于 0，则不限制切分个数，全部切分1234567891011//func SplitN(s, sep string, n int) []stringfunc main() &#123; s := "Hello, 世界! Hello!" ss := strings.SplitN(s, " ", 2) fmt.Printf("%q\n", ss) // ["Hello," "世界! Hello!"] ss = strings.SplitN(s, " ", -1) fmt.Printf("%q\n", ss) // ["Hello," "世界!" "Hello!"] ss = strings.SplitN(s, "", 3) fmt.Printf("%q\n", ss) // ["H" "e" "llo, 世界! Hello!"]&#125;// SplitAfterN 以 sep 为分隔符，将 s 切分成多个子串，结果中包含 sep 本身// 如果 sep 为空，则将 s 切分成 Unicode 字符列表。// 如果 s 中没有 sep 子串，则将整个 s 作为 []string 的第一个元素返回// 参数 n 表示最多切分出几个子串，超出的部分将不再切分。// 如果 n 为 0，则返回 nil，如果 n 小于 0，则不限制切分个数，全部切分1234567891011//func SplitAfterN(s, sep string, n int) []stringfunc main() &#123; s := "Hello, 世界! Hello!" ss := strings.SplitAfterN(s, " ", 2) fmt.Printf("%q\n", ss) // ["Hello, " "世界! Hello!"] ss = strings.SplitAfterN(s, " ", -1) fmt.Printf("%q\n", ss) // ["Hello, " "世界! " "Hello!"] ss = strings.SplitAfterN(s, "", 3) fmt.Printf("%q\n", ss) // ["H" "e" "llo, 世界! Hello!"]&#125;// Split 以 sep 为分隔符，将 s 切分成多个子切片，结果中不包含 sep 本身// 如果 sep 为空，则将 s 切分成 Unicode 字符列表。// 如果 s 中没有 sep 子串，则将整个 s 作为 []string 的第一个元素返回1234567891011//func Split(s, sep string) []stringfunc main() &#123; s := "Hello, 世界! Hello!" ss := strings.Split(s, " ") fmt.Printf("%q\n", ss) // ["Hello," "世界!" "Hello!"] ss = strings.Split(s, ", ") fmt.Printf("%q\n", ss) // ["Hello" "世界! Hello!"] ss = strings.Split(s, "") fmt.Printf("%q\n", ss) // 单个字符列表&#125;// SplitAfter 以 sep 为分隔符，将 s 切分成多个子切片，结果中包含 sep 本身// 如果 sep 为空，则将 s 切分成 Unicode 字符列表。// 如果 s 中没有 sep 子串，则将整个 s 作为 []string 的第一个元素返回1234567891011//func SplitAfter(s, sep string) []stringfunc main() &#123; s := "Hello, 世界! Hello!" ss := strings.SplitAfter(s, " ") fmt.Printf("%q\n", ss) // ["Hello, " "世界! " "Hello!"] ss = strings.SplitAfter(s, ", ") fmt.Printf("%q\n", ss) // ["Hello, " "世界! Hello!"] ss = strings.SplitAfter(s, "") fmt.Printf("%q\n", ss) // 单个字符列表&#125;// Fields 以连续的空白字符为分隔符，将 s 切分成多个子串，结果中不包含空白字符本身// 空白字符有：\t, \n, \v, \f, \r, ‘ ‘, U+0085 (NEL), U+00A0 (NBSP)// 如果 s 中只包含空白字符，则返回一个空列表1234567//func Fields(s string) []stringfunc main() &#123; s := "Hello, 世界! Hello!" ss := strings.Fields(s) fmt.Printf("%q\n", ss) // ["Hello," "世界!" "Hello!"]&#125;// FieldsFunc 以一个或多个满足 f(rune) 的字符为分隔符，// 将 s 切分成多个子串，结果中不包含分隔符本身。// 如果 s 中没有满足 f(rune) 的字符，则返回一个空列表。1234567891011//func FieldsFunc(s string, f func(rune) bool) []stringfunc isSlash(r rune) bool &#123; return r == '\\' || r == '/'&#125; func main() &#123; s := "C:\\Windows\\System32\\FileName" ss := strings.FieldsFunc(s, isSlash) fmt.Printf("%q\n", ss) // ["C:" "Windows" "System32" "FileName"]&#125;// Join 将 a 中的子串连接成一个单独的字符串，子串之间用 sep 分隔 1234567//func Join(a []string, sep string) stringfunc main() &#123; ss := []string&#123;"Monday", "Tuesday", "Wednesday"&#125; s := strings.Join(ss, "|") fmt.Println(s)&#125; // HasPrefix 判断字符串 s 是否以 prefix 开头 123456789func HasPrefix(s, prefix string) boolfunc main() &#123; s := "Hello 世界!" b := strings.HasPrefix(s, "hello") fmt.Println(b) // false b = strings.HasPrefix(s, "Hello") fmt.Println(b) // true&#125; // HasSuffix 判断字符串 s 是否以 prefix 结尾 123456789//func HasSuffix(s, suffix string) boolfunc main() &#123; s := "Hello 世界!" b := strings.HasSuffix(s, "世界") fmt.Println(b) // false b = strings.HasSuffix(s, "世界!") fmt.Println(b) // true&#125; // Map 将 s 中满足 mapping(rune) 的字符替换为 mapping(rune) 的返回值。 // 如果 mapping(rune) 返回负数，则相应的字符将被删除。 123456789101112131415//func Map(mapping func(rune) rune, s string) stringfunc Slash(r rune) rune &#123; if r == '\\' &#123; return '/' &#125; return r&#125;func main() &#123; s := "C:\\Windows\\System32\\FileName" ms := strings.Map(Slash, s) fmt.Printf("%q\n", ms) // "C:/Windows/System32/FileName"&#125; // Repeat 将 count 个字符串 s 连接成一个新的字符串 1234567//func Repeat(s string, count int) stringfunc main() &#123; s := "Hello!" rs := strings.Repeat(s, 3) fmt.Printf("%q\n", rs) // "Hello!Hello!Hello!"&#125; // ToUpper 将 s 中的所有字符修改为其大写格式// 对于非 ASCII 字符，它的大写格式需要查表转换func ToUpper(s string) string// ToLower 将 s 中的所有字符修改为其小写格式// 对于非 ASCII 字符，它的小写格式需要查表转换func ToLower(s string) string// ToTitle 将 s 中的所有字符修改为其 Title 格式// 大部分字符的 Title 格式就是其 Upper 格式// 只有少数字符的 Title 格式是特殊字符// 这里的 ToTitle 主要给 Title 函数调用func ToTitle(s string) string123456789func main() &#123; s := "heLLo worLd Ａｂｃ" us := strings.ToUpper(s) ls := strings.ToLower(s) ts := strings.ToTitle(s) fmt.Printf("%q\n", us) // "HELLO WORLD ＡＢＣ" fmt.Printf("%q\n", ls) // "hello world ａｂｃ" fmt.Printf("%q\n", ts) // "HELLO WORLD ＡＢＣ"&#125;1234567891011121314// 获取非 ASCII 字符的 Title 格式列表func main() &#123; for _, cr := range unicode.CaseRanges &#123; // u := uint32(cr.Delta[unicode.UpperCase]) // 大写格式 // l := uint32(cr.Delta[unicode.LowerCase]) // 小写格式 t := uint32(cr.Delta[unicode.TitleCase]) // Title 格式 // if t != 0 &amp;&amp; t != u &#123; if t != 0 &#123; for i := cr.Lo; i &lt;= cr.Hi; i++ &#123; fmt.Printf("%c -&gt; %c\n", i, i+t) &#125; &#125; &#125;&#125; // ToUpperSpecial 将 s 中的所有字符修改为其大写格式。// 优先使用 _case 中的规则进行转换func ToUpperSpecial(_case unicode.SpecialCase, s string) string// ToLowerSpecial 将 s 中的所有字符修改为其小写格式。// 优先使用 _case 中的规则进行转换func ToLowerSpecial(_case unicode.SpecialCase, s string) string// ToTitleSpecial 将 s 中的所有字符修改为其 Title 格式。// 优先使用 _case 中的规则进行转换func ToTitleSpecial(_case unicode.SpecialCase, s string) string_case 规则说明，以下列语句为例：unicode.CaseRange{‘A’, ‘Z’, [unicode.MaxCase]rune{3, -3, 0}}·其中 ‘A’, ‘Z’ 表示此规则只影响 ‘A’ 到 ‘Z’ 之间的字符。·其中 [unicode.MaxCase]rune 数组表示：当使用 ToUpperSpecial 转换时，将字符的 Unicode 编码与第一个元素值（3）相加当使用 ToLowerSpecial 转换时，将字符的 Unicode 编码与第二个元素值（-3）相加当使用 ToTitleSpecial 转换时，将字符的 Unicode 编码与第三个元素值（0）相加123456789101112131415161718192021func main() &#123; // 定义转换规则 var _MyCase = unicode.SpecialCase&#123; // 将半角逗号替换为全角逗号，ToTitle 不处理 unicode.CaseRange&#123;',', ',', [unicode.MaxCase]rune&#123;'，' - ',', '，' - ',', 0&#125;&#125;, // 将半角句号替换为全角句号，ToTitle 不处理 unicode.CaseRange&#123;'.', '.', [unicode.MaxCase]rune&#123;'。' - '.', '。' - '.', 0&#125;&#125;, // 将 ABC 分别替换为全角的 ＡＢＣ、ａｂｃ，ToTitle 不处理 unicode.CaseRange&#123;'A', 'C', [unicode.MaxCase]rune&#123;'Ａ' - 'A', 'ａ' - 'A', 0&#125;&#125;, &#125; s := "ABCDEF,abcdef." us := strings.ToUpperSpecial(_MyCase, s) fmt.Printf("%q\n", us) // "ＡＢＣDEF，ABCDEF。" ls := strings.ToLowerSpecial(_MyCase, s) fmt.Printf("%q\n", ls) // "ａｂｃdef，abcdef。" ts := strings.ToTitleSpecial(_MyCase, s) fmt.Printf("%q\n", ts) // "ABCDEF,ABCDEF."&#125;// Title 将 s 中的所有单词的首字母修改为其 Title 格式// BUG: Title 规则不能正确处理 Unicode 标点符号func Title(s string) string123456func main() &#123; s := "heLLo worLd" ts := strings.Title(s) fmt.Printf("%q\n", ts) // "HeLLo WorLd"&#125; // TrimLeftFunc 将删除 s 头部连续的满足 f(rune) 的字符func TrimLeftFunc(s string, f func(rune) bool) string-———————————————————–// TrimRightFunc 将删除 s 尾部连续的满足 f(rune) 的字符func TrimRightFunc(s string, f func(rune) bool) string12345678910func isSlash(r rune) bool &#123; return r == '\\' || r == '/'&#125; func main() &#123; s := "\\\\HostName\\C\\Windows\\" ts := strings.TrimRightFunc(s, isSlash) fmt.Printf("%q\n", ts) // "\\\\HostName\\C\\Windows"&#125;// TrimFunc 将删除 s 首尾连续的满足 f(rune) 的字符func TrimFunc(s string, f func(rune) bool) string123456789func isSlash(r rune) bool &#123; return r == '\\' || r == '/'&#125;func main() &#123; s := "\\\\HostName\\C\\Windows\\" ts := strings.TrimFunc(s, isSlash) fmt.Printf("%q\n", ts) // "HostName\\C\\Windows"&#125;// 返回 s 中第一个满足 f(rune) 的字符的字节位置。// 如果没有满足 f(rune) 的字符，则返回 -1func IndexFunc(s string, f func(rune) bool) int123456789func isSlash(r rune) bool &#123; return r == '\\' || r == '/'&#125; func main() &#123; s := "C:\\Windows\\System32" i := strings.IndexFunc(s, isSlash) fmt.Printf("%v\n", i) // 2&#125;// 返回 s 中最后一个满足 f(rune) 的字符的字节位置。// 如果没有满足 f(rune) 的字符，则返回 -1func LastIndexFunc(s string, f func(rune) bool) int12345678910func isSlash(r rune) bool &#123; return r == '\\' || r == '/'&#125; func main() &#123; s := "C:\\Windows\\System32" i := strings.LastIndexFunc(s, isSlash) fmt.Printf("%v\n", i) // 10&#125;// Trim 将删除 s 首尾连续的包含在 cutset 中的字符func Trim(s string, cutset string) string12345func main() &#123; s := " Hello 世界! " ts := strings.Trim(s, " Helo!") fmt.Printf("%q\n", ts) // "世界"&#125;// TrimLeft 将删除 s 头部连续的包含在 cutset 中的字符//其实是从左往右删除s的在cutset中任意字符，直到碰见第一个不在 cutset中的字符返回func TrimLeft(s string, cutset string) string12345func main() &#123; s := " Hello 世界! " ts := strings.TrimLeft(s, " Helo") fmt.Printf("%q\n", ts) // "世界! "&#125;// TrimRight 将删除 s 尾部连续的包含在 cutset 中的字符//其实是从右往左删除s的在cutset中任意字符，直到碰见第一个不在 cutset中的字符返回func TrimRight(s string, cutset string) string12345func main() &#123; s := " Hello 世界! " ts := strings.TrimRight(s, " 世界!") fmt.Printf("%q\n", ts) // " Hello"&#125;// TrimSpace 将删除 s 首尾连续的的空白字符func TrimSpace(s string) string12345func main() &#123; s := " Hello 世界! " ts := strings.TrimSpace(s) fmt.Printf("%q\n", ts) // "Hello 世界!"&#125;// TrimPrefix 删除 s 头部的 prefix 字符串 // 如果 s 不是以 prefix 开头，则返回原始 s func TrimPrefix(s, prefix string) string 123456func main() &#123; s := "Hello 世界!" ts := strings.TrimPrefix(s, "Hello") fmt.Printf("%q\n", ts) // " 世界"&#125; -———————————————————– // TrimSuffix 删除 s 尾部的 suffix 字符串 // 如果 s 不是以 suffix 结尾，则返回原始 s func TrimSuffix(s, suffix string) string 12345func main() &#123; s := "Hello 世界!!!!!" ts := strings.TrimSuffix(s, "!!!!") fmt.Printf("%q\n", ts) // " 世界"&#125; 注：TrimSuffix只是去掉s字符串结尾的suffix字符串，只是去掉１次，而TrimRight是一直去掉s字符串右边的字符串，只要有响应的字符串就去掉，是一个多次的过程，这也是二者的本质区别． // Replace 返回 s 的副本，并将副本中的 old 字符串替换为 new 字符串// 替换次数为 n 次，如果 n 为 -1，则全部替换// 如果 old 为空，则在副本的每个字符之间都插入一个 newfunc Replace(s, old, new string, n int) string 1234567func main() &#123; s := "Hello 世界！" s = strings.Replace(s, " ", ",", -1) fmt.Println(s) s = strings.Replace(s, "", "|", -1) fmt.Println(s)&#125; -———————————————————– // EqualFold 判断 s 和 t 是否相等。忽略大小写，同时它还会对特殊字符进行转换 // 比如将“ϕ”转换为“Φ”、将“Ǆ”转换为“ǅ”等，然后再进行比较 func EqualFold(s, t string) bool 123456func main() &#123; s1 := "Hello 世界! ϕ Ǆ" s2 := "hello 世界! Φ ǅ" b := strings.EqualFold(s1, s2) fmt.Printf("%v\n", b) // true&#125; ============================================================ // reader.go -———————————————————– // Reader 结构通过读取字符串，实现了 io.Reader，io.ReaderAt， // io.Seeker，io.WriterTo，io.ByteScanner，io.RuneScanner 接口 123456type Reader struct &#123; s string // 要读取的字符串 i int // 当前读取的索引位置，从 i 处开始读取数据 prevRune int // 读取的前一个字符的索引位置，小于 0 表示之前未读取字符&#125; // 通过字符串 s 创建 strings.Reader 对象 // 这个函数类似于 bytes.NewBufferString // 但比 bytes.NewBufferString 更有效率，而且只读 func NewReader(s string) *Reader { return &amp;Reader{s, 0, -1} } -———————————————————– // Len 返回 r.i 之后的所有数据的字节长度 func (r *Reader) Len() int 123456789func main() &#123; s := "Hello 世界!" // 创建 Reader r := strings.NewReader(s) // 获取字符串的编码长度 fmt.Println(r.Len()) // 13&#125; -———————————————————– // Read 将 r.i 之后的所有数据写入到 b 中（如果 b 的容量足够大） // 返回读取的字节数和读取过程中遇到的错误 // 如果无可读数据，则返回 io.EOF func (r *Reader) Read(b []byte) (n int, err error) 123456789101112func main() &#123; s := "Hello World!" // 创建 Reader r := strings.NewReader(s) // 创建长度为 5 个字节的缓冲区 b := make([]byte, 5) // 循环读取 r 中的字符串 for n, _ := r.Read(b); n &gt; 0; n, _ = r.Read(b) &#123; fmt.Printf("%q, ", b[:n]) // "Hello", " Worl", "d!" &#125;&#125; // ReadAt 将 off 之后的所有数据写入到 b 中（如果 b 的容量足够大） // 返回读取的字节数和读取过程中遇到的错误 // 如果无可读数据，则返回 io.EOF // 如果数据被一次性读取完毕，则返回 io.EOF func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) 123456789101112131415func main() &#123; s := "Hello World!" // 创建 Reader r := strings.NewReader(s) // 创建长度为 5 个字节的缓冲区 b := make([]byte, 5) // 读取 r 中指定位置的字符串 n, _ := r.ReadAt(b, 0) fmt.Printf("%q\n", b[:n]) // "Hello" // 读取 r 中指定位置的字符串 n, _ = r.ReadAt(b, 6) fmt.Printf("%q\n", b[:n]) // "World"&#125; // ReadByte 将 r.i 之后的一个字节写入到返回值 b 中 // 返回读取的字节和读取过程中遇到的错误 // 如果无可读数据，则返回 io.EOF func (r *Reader) ReadByte() (b byte, err error) 1234567891011func main() &#123; s := "Hello World!" // 创建 Reader r := strings.NewReader(s) // 读取 r 中的一个字节 for i := 0; i &lt; 3; i++ &#123; b, _ := r.ReadByte() fmt.Printf("%q, ", b) // 'H', 'e', 'l', &#125;&#125; // UnreadByte 撤消前一次的 ReadByte 操作，即 r.i– func (r *Reader) UnreadByte() error 1234567891011func main() &#123; s := "Hello World!" // 创建 Reader r := strings.NewReader(s) // 读取 r 中的一个字节 for i := 0; i &lt; 3; i++ &#123; b, _ := r.ReadByte() fmt.Printf("%q, ", b) // 'H', 'H', 'H', r.UnreadByte() // 撤消前一次的字节读取操作 &#125;&#125; // ReadRune 将 r.i 之后的一个字符写入到返回值 ch 中// ch： 读取的字符// size：ch 的编码长度// err： 读取过程中遇到的错误// 如果无可读数据，则返回 io.EOF// 如果 r.i 之后不是一个合法的 UTF-8 字符编码，则返回 utf8.RuneError 字符func (r *Reader) ReadRune() (ch rune, size int, err error) 123456789101112func main() &#123; s := "你好 世界！" // 创建 Reader r := strings.NewReader(s) // 读取 r 中的一个字符 for i := 0; i &lt; 5; i++ &#123; b, n, _ := r.ReadRune() fmt.Printf(`"%c:%v", `, b, n) // "你:3", "好:3", " :1", "世:3", "界:3", &#125;&#125; // 撤消前一次的 ReadRune 操作 func (r *Reader) UnreadRune() error 12345678910111213func main() &#123; s := "你好 世界！" // 创建 Reader r := strings.NewReader(s) // 读取 r 中的一个字符 for i := 0; i &lt; 5; i++ &#123; b, _, _ := r.ReadRune() fmt.Printf("%q, ", b) // '你', '你', '你', '你', '你', r.UnreadRune() // 撤消前一次的字符读取操作 &#125;&#125; // Seek 用来移动 r 中的索引位置 // offset：要移动的偏移量，负数表示反向移动 // whence：从那里开始移动，0：起始位置，1：当前位置，2：结尾位置 // 如果 whence 不是 0、1、2，则返回错误信息 // 如果目标索引位置超出字符串范围，则返回错误信息 // 目标索引位置不能超出 1 &lt;&lt; 31，否则返回错误信息 func (r *Reader) Seek(offset int64, whence int) (int64, error) 123456789101112131415func main() &#123; s := "Hello World!" // 创建 Reader r := strings.NewReader(s) // 创建读取缓冲区 b := make([]byte, 5) // 读取 r 中指定位置的内容 r.Seek(6, 0) // 移动索引位置到第 7 个字节 r.Read(b) // 开始读取 fmt.Printf("%q\n", b) r.Seek(-5, 1) // 将索引位置移回去 r.Read(b) // 继续读取 fmt.Printf("%q\n", b)&#125; -———————————————————– // WriteTo 将 r.i 之后的数据写入接口 w 中 func (r *Reader) WriteTo(w io.Writer) (n int64, err error) 1234567891011func main() &#123; s := "Hello World!" // 创建 Reader r := strings.NewReader(s) // 创建 bytes.Buffer 对象，它实现了 io.Writer 接口 buf := bytes.NewBuffer(nil) // 将 r 中的数据写入 buf 中 r.WriteTo(buf) fmt.Printf("%q\n", buf) // "Hello World!"&#125; // replace.go 12345// Replacer 根据一个替换列表执行替换操作type Replacer struct &#123;Replace(s string) stringWriteString(w io.Writer, s string) (n int, err error)&#125; -———————————————————– // NewReplacer 通过“替换列表”创建一个 Replacer 对象。// 按照“替换列表”中的顺序进行替换，只替换非重叠部分。// 如果参数的个数不是偶数，则抛出异常。// 如果在“替换列表”中有相同的“查找项”，则后面重复的“查找项”会被忽略func NewReplacer(oldnew …string) *Replacer -———————————————————– // Replace 返回对 s 进行“查找和替换”后的结果// Replace 使用的是 Boyer-Moore 算法，速度很快func (r *Replacer) Replace(s string) string 12345678910111213141516func main() &#123; srp := strings.NewReplacer("Hello", "你好", "World", "世界", "!", "！") s := "Hello World!Hello World!hello world!" rst := srp.Replace(s) fmt.Print(rst) // 你好 世界！你好 世界！hello world！&#125;func main() &#123; wl := []string&#123;"Hello", "Hi", "Hello", "你好"&#125; srp := strings.NewReplacer(wl...) s := "Hello World! Hello World! hello world!" rst := srp.Replace(s) fmt.Print(rst) // Hi World! Hi World! hello world!&#125; // WriteString 对 s 进行“查找和替换”，然后将结果写入 w 中 func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error) 12345678func main() &#123; wl := []string&#123;"Hello", "你好", "World", "世界", "!", "！"&#125; srp := strings.NewReplacer(wl...) s := "Hello World!Hello World!hello world!" srp.WriteString(os.Stdout, s) // 你好 世界！你好 世界！hello world！&#125;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bytes 包中的函数和方法]]></title>
    <url>%2F2019%2F05%2F22%2Fbytes%20%E5%8C%85%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[bytes 包中的函数和方法// bytes 包实现了用于操作 []byte 的函数，类似于 strings 包中的函数 // bytes.go -———————————————————– // Compare 用于比较两个 []byte，并返回 int 型结果// a == b 返回 0// a &lt; b 返回 -1// a &gt; b 返回 1// 如果参数为 nil 则相当于传入一个空 []bytefunc Compare(a, b []byte) int -———————————————————– // 功能类似于 strings 包中的同名函数// Count 计算 sep 在 s 中的非重叠个数// 如果 sep 为空，则返回 s 中的字符个数 + 1func Count(s, sep []byte) int -———————————————————– // 功能类似于 strings 包中的同名函数// Contains 判断 b 中是否包含 subslice// 如果 subslice 为空，则返回 truefunc Contains(b, subslice []byte) bool -———————————————————– // 功能类似于 strings 包中的同名函数// Index 返回 sep 在 s 中第一次出现的位置// 如果找不到，则返回 -1，如果 sep 为空，则返回 0func Index(s, sep []byte) int -———————————————————– // 功能类似于 strings 包中的同名函数// LastIndex 返回 sep 在 s 中最后一次出现的字节位置// 如果找不到，则返回 -1，如果 sep 为空，则返回 s 的长度func LastIndex(s, sep []byte) int -———————————————————– // 功能类似于 strings 包中的同名函数// IndexRune 返回 r 的编码在 s 中第一次出现的位置// 如果找不到，则返回 -1func IndexRune(s []byte, r rune) int -———————————————————– // 功能类似于 strings 包中的同名函数// IndexAny 返回 chars 中的任何一个字符在 s 中第一次出现的位置// 如果找不到，则返回 -1，如果 chars 为空，则返回 -1func IndexAny(s []byte, chars string) int -———————————————————– // 功能类似于 strings 包中的同名函数// LastIndexAny 返回 chars 中的任何一个字符在 s 中最后一次出现的位置// 如果找不到，则返回 -1，如果 chars 为空，也返回 -1func LastIndexAny(s []byte, chars string) int -———————————————————– // 功能类似于 strings 包中的同名函数// SplitN 以 sep 为分隔符，将 s 切分成多个子串，结果中不包含 sep 本身// 如果 sep 为空，则将 s 切分成 Unicode 字符列表// 如果 s 中没有 sep，则将整个 s 作为 [][]byte 的第一个元素返回// 参数 n 表示最多切分出几个子串，超出的部分将不再切分// 如果 n 为 0，则返回 nil，如果 n 小于 0，则不限制切分个数，全部切分func SplitN(s, sep []byte, n int) [][]byte -———————————————————– // 功能类似于 strings 包中的同名函数// SplitAfterN 和 SplitN 的功能一样，只不过结果中包含 sepfunc SplitAfterN(s, sep []byte, n int) [][]byte -———————————————————– // 功能类似于 strings 包中的同名函数// Split 以 sep 为分隔符，将 s 切分成多个子串，结果中不包含 sep 本身// 如果 sep 为空，则将 s 切分成 Unicode 字符列表。// 如果 s 中没有 sep 子串，则将整个 s 作为 []string 的第一个元素返回func Split(s, sep []byte) [][]byte -———————————————————– // 功能类似于 strings 包中的同名函数// SplitAfter 和 Split 的功能一样，只不过结果中包含 sepfunc SplitAfter(s, sep []byte) [][]byte -———————————————————– // 功能类似于 strings 包中的同名函数// Fields 以连续的空白字符为分隔符，将 s 切分成多个子串，结果中不包含空白字符本身// 空白字符有：\t, \n, \v, \f, \r, ‘ ‘, U+0085 (NEL), U+00A0 (NBSP)// 如果 s 中只包含空白字符，则返回一个空列表func Fields(s []byte) [][]byte -———————————————————– // 功能类似于 strings 包中的同名函数// FieldsFunc 以一个或多个连续的满足 f(rune) 的字符为分隔符，// 将 s 切分成多个子串，结果中不包含分隔符本身// 如果 s 中没有满足 f(rune) 的字符，则返回一个空列表func FieldsFunc(s []byte, f func(rune) bool) [][]byte -———————————————————– // 功能类似于 strings 包中的同名函数// Join 将 s 中的子串连接成一个单独的 []byte，子串之间用 sep 分隔func Join(s [][]byte, sep []byte) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// HasPrefix 判断 s 是否以 prefix 开头// 如果 prefix 为空，也返回 truefunc HasPrefix(s, prefix []byte) bool -———————————————————– // 功能类似于 strings 包中的同名函数// HasPrefix 判断 s 是否以 prefix 结尾// 如果 suffix 为空，也返回 truefunc HasSuffix(s, suffix []byte) bool -———————————————————– // 功能类似于 strings 包中的同名函数// Map 将 s 中满足 mapping(rune) 的字符替换为 mapping(rune) 的返回值// 如果 mapping(rune) 返回负数，则相应的字符将被删除func Map(mapping func(r rune) rune, s []byte) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// Repeat 将 count 个 b 连接成一个新的 []bytefunc Repeat(b []byte, count int) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// ToUpper 将 s 中的所有字符修改为其大写格式// 对于非 ASCII 字符，它的大写格式需要查表转换func ToUpper(s []byte) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// ToLower 将 s 中的所有字符修改为其小写格式// 对于非 ASCII 字符，它的小写格式需要查表转换func ToLower(s []byte) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// ToTitle 将 s 中的所有字符修改为其 Title 格式// 大部分字符的 Title 格式就是其 Upper 格式// 只有少数字符的 Title 格式是特殊字符// 这里的 ToTitle 主要给 Title 函数调用func ToTitle(s []byte) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// ToUpperSpecial 将 s 中的所有字符修改为其大写格式// 优先使用 _case 中的规则进行转换func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// ToLowerSpecial 将 s 中的所有字符修改为其小写格式// 优先使用 _case 中的规则进行转换func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// ToTitleSpecial 将 s 中的所有字符修改为其 Title 格式// 优先使用 _case 中的规则进行转换func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// Title 将 s 中的所有单词的首字母修改为其 Title 格式// BUG: Title 规则不能正确处理 Unicode 标点符号func Title(s []byte) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// TrimLeftFunc 将删除 s 头部连续的满足 f(rune) 的字符func TrimLeftFunc(s []byte, f func(r rune) bool) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// TrimRightFunc 将删除 s 尾部连续的满足 f(rune) 的字符func TrimRightFunc(s []byte, f func(r rune) bool) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// TrimFunc 将删除 s 首尾连续的满足 f(rune) 的字符func TrimFunc(s []byte, f func(r rune) bool) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// TrimPrefix 删除 s 头部的 prefix 字符串// 如果 s 不是以 prefix 开头，则返回原始 sfunc TrimPrefix(s, prefix []byte) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// TrimSuffix 删除 s 尾部的 suffix 字符串// 如果 s 不是以 suffix 结尾，则返回原始 sfunc TrimSuffix(s, suffix []byte) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// IndexFunc 返回 s 中第一个满足 f(rune) 的字符的字节位置// 如果没有满足 f(rune) 的字符，则返回 -1func IndexFunc(s []byte, f func(r rune) bool) int -———————————————————– // 功能类似于 strings 包中的同名函数// LastIndexFunc 返回 s 中最后一个满足 f(rune) 的字符的字节位置// 如果没有满足 f(rune) 的字符，则返回 -1func LastIndexFunc(s []byte, f func(r rune) bool) int -———————————————————– // 功能类似于 strings 包中的同名函数// Trim 将删除 s 首尾连续的包含在 cutset 中的字符func Trim(s []byte, cutset string) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// TrimLeft 将删除 s 头部连续的包含在 cutset 中的字符func TrimLeft(s []byte, cutset string) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// TrimRight 将删除 s 尾部连续的包含在 cutset 中的字符func TrimRight(s []byte, cutset string) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// TrimSpace 将删除 s 首尾连续的的空白字符func TrimSpace(s []byte) []byte -———————————————————– // Runes 将 s 切分为 Unicode 码点列表func Runes(s []byte) []rune -———————————————————– // 功能类似于 strings 包中的同名函数// Replace 将 s 中的 old 子串替换为 new 子串并返回// 替换次数为 n 次，如果 n 为 -1，则全部替换// 如果 old 为空，则在每个字符之间都插入一个 newfunc Replace(s, old, new []byte, n int) []byte -———————————————————– // 功能类似于 strings 包中的同名函数// EqualFold 判断 s 和 t 是否相等。忽略大小写，同时它还会对特殊字符进行转换// 比如将“ϕ”转换为“Φ”、将“Ǆ”转换为“ǅ”等，然后再进行比较func EqualFold(s, t []byte) bool ============================================================ // bytes_decl.go -———————————————————– // IndexByte 返回 c 在 s 中第一次出现的位置// 如果找不到，则返回 -1func IndexByte(s []byte, c byte) int -———————————————————– // Equal 判断 a 和 b 是否相等// 如果参数为 nil，则被视为空 []bytefunc Equal(a, b []byte) bool ============================================================ // reader.go -———————————————————– type Reader struct {// 私有字段} // 通过 []byte 创建一个 bytes.Reader 对象func NewReader(b []byte) *Reader -———————————————————– // 返回 r 中未读取的数据的长度func (r *Reader) Len() int -———————————————————– // 实现 io.Reader 接口func (r *Reader) Read(b []byte) (n int, err error) -———————————————————– // 实现 io.ReaderAt 接口func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) -———————————————————– // 实现 io.ByteScanner 接口func (r Reader) ReadByte() (b byte, err error)func (r Reader) UnreadByte() error -———————————————————– // 实现 io.RuneScanner 接口func (r Reader) ReadRune() (ch rune, size int, err error)func (r Reader) UnreadRune() error -———————————————————– // 实现 io.Seeker 接口func (r *Reader) Seek(offset int64, whence int) (int64, error) -———————————————————– // 实现 io.WriterTo 接口func (r *Reader) WriteTo(w io.Writer) (n int64, err error) ============================================================ // buffer.go -———————————————————– // Buffer 实现了带缓存的输入输出操作// 缓存的容量会根据需要自动扩展// 如果缓存太大，无法继续扩展，则会引发 panic(ErrTooLarge)type Buffer struct {// 私有字段} // 通过 []byte 或 string 创建 bytes.Buffer 对象func NewBuffer(buf []byte) Bufferfunc NewBufferString(s string) Buffer -———————————————————– // 返回 b 中数据的切片func (b *Buffer) Bytes() []byte -———————————————————– // 返回 b 中取数据的副本func (b *Buffer) String() string -———————————————————– // 返回 b 中数据的长度func (b *Buffer) Len() int -———————————————————– // Truncate 将缓冲区中的数据截短为前 n 字节，截掉的部分将被丢弃// 如果 n 是负数或 n 超出了缓冲区总长度，则会引发 panicfunc (b *Buffer) Truncate(n int) -———————————————————– // Reset 方法用于重置缓存，即清空缓存中的数据// b.Reset() 相当于 b.Truncate(0)。func (b *Buffer) Reset() -———————————————————– // Grow 将缓存长度向后扩展 n 个字节，不返回任何数据。// 如果 n 是复数，将引发 panic，如果无法扩展缓存长度，则会引发 panic(ErrTooLarge)func (b *Buffer) Grow(n int) -———————————————————– // 实现了 io.Writer 接口func (b *Buffer) Write(p []byte) (n int, err error) -———————————————————– // 功能同 Write，只不过参数为字符串类型func (b *Buffer) WriteString(s string) (n int, err error) -———————————————————– // 实现 io.ReaderFrom 接口func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) -———————————————————– // 实现了 io.WriterTo 接口func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) -———————————————————– // 实现了 io.ByteWriter 接口func (b *Buffer) WriteByte(c byte) error -———————————————————– // WriteRune 将一个字符 r 写入到对象的数据流中// 返回写入过程中遇到的任何错误func (b *Buffer) WriteRune(r rune) (n int, err error) -———————————————————– // 实现了 io.Reader 接口func (b *Buffer) Read(p []byte) (n int, err error) -———————————————————– // Next 读出缓存中前 n 个字节的数据，并返回其引用// 如果 n 大于缓存中数据的长度，则读出所有数据// 被读出的数据在下一次读写操作之前是有效的// 下一次读写操作时，所引用的数据可能会被覆盖func (b *Buffer) Next(n int) []byte -———————————————————– // 实现 io.ByteScanner 接口func (b Buffer) ReadByte() (c byte, err error)func (b Buffer) UnreadByte() error -———————————————————– // 实现 io.RuneScanner 接口func (b Buffer) ReadRune() (r rune, size int, err error)func (b Buffer) UnreadRune() error -———————————————————– // 类似于 bufio 包中的 Reader.ReadBytes 和 Reader.ReadString 方法// ReadBytes 在 b 中查找 delim 并读出 delim 及其之前的所有数据// ReadString 功能同 ReadBytes，只不过返回的是一个字符串func (b Buffer) ReadBytes(delim byte) (line []byte, err error)func (b Buffer) ReadString(delim byte) (line string, err error)]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[strconv 包中的函数和方法]]></title>
    <url>%2F2019%2F05%2F22%2Fstrconv%20%E5%8C%85%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[strconv 包中的函数和方法// atob.go -———————————————————– // ParseBool 将字符串转换为布尔值// 它接受真值：1, t, T, TRUE, true, True// 它接受假值：0, f, F, FALSE, false, False.// 其它任何值都返回一个错误func ParseBool(str string) (value bool, err error) 1234567891011121314151617181920212223package mainimport ( "fmt" "strconv")func main() &#123; fmt.Println(strconv.ParseBool("1")) // true fmt.Println(strconv.ParseBool("t")) // true fmt.Println(strconv.ParseBool("T")) // true fmt.Println(strconv.ParseBool("true")) // true fmt.Println(strconv.ParseBool("True")) // true fmt.Println(strconv.ParseBool("TRUE")) // true fmt.Println(strconv.ParseBool("TRue")) // false strconv.ParseBool: parsing "TRue": invalid syntax fmt.Println(strconv.ParseBool("0")) // false fmt.Println(strconv.ParseBool("f")) // false fmt.Println(strconv.ParseBool("F")) // false fmt.Println(strconv.ParseBool("false")) // false fmt.Println(strconv.ParseBool("False")) // false fmt.Println(strconv.ParseBool("FALSE")) // false fmt.Println(strconv.ParseBool("FALse")) // false strconv.ParseBool: parsing "FAlse": invalid syntax&#125; // FormatBool 将布尔值转换为字符串 “true” 或 “false” func FormatBool(b bool) string 1234func main() &#123; fmt.Println(strconv.FormatBool(0 &lt; 1)) // true fmt.Println(strconv.FormatBool(0 &gt; 1)) // false&#125; // AppendBool 将布尔值 b 转换为字符串 “true” 或 “false”// 然后将结果追加到 dst 的尾部，返回追加后的 []bytefunc AppendBool(dst []byte, b bool) []byte 1234567func main() &#123; rst := make([]byte, 0) rst = strconv.AppendBool(rst, 0 &lt; 1) fmt.Printf("%s\n", rst) // true rst = strconv.AppendBool(rst, 0 &gt; 1) fmt.Printf("%s\n", rst) // truefalse&#125; // atof.go -———————————————————– // ParseFloat 将字符串转换为浮点数// s：要转换的字符串// bitSize：指定浮点类型（32:float32、64:float64）// 如果 s 是合法的格式，而且接近一个浮点值，// 则返回浮点数的四舍五入值（依据 IEEE754 的四舍五入标准）// 如果 s 不是合法的格式，则返回“语法错误”// 如果转换结果超出 bitSize 范围，则返回“超出范围”func ParseFloat(s string, bitSize int) (f float64, err error) 123456789func main() &#123; s := "0.12345678901234567890" f, err := strconv.ParseFloat(s, 32) fmt.Println(f, err) // 0.12345679104328156 fmt.Println(float32(f), err) // 0.12345679 f, err = strconv.ParseFloat(s, 64) fmt.Println(f, err) // 0.12345678901234568&#125; // atoi.go -———————————————————– // ErrRange 表示值超出范围var ErrRange = errors.New(“value out of range”) // ErrSyntax 表示语法不正确var ErrSyntax = errors.New(“invalid syntax”) // NumError 记录转换失败type NumError struct {Func string // 失败的函数名(ParseBool, ParseInt, ParseUint, ParseFloat)Num string // 输入的值Err error // 失败的原因(ErrRange, ErrSyntax)} // int 或 uint 类型的长度(32 或 64)const IntSize = intSizeconst intSize = 32 &lt;&lt; uint(^uint(0)&gt;&gt;63) // 实现 Error 接口，输出错误信息func (e *NumError) Error() string -———————————————————– // ParseInt 将字符串转换为 int 类型// s：要转换的字符串// base：进位制（2 进制到 36 进制）// bitSize：指定整数类型（0:int、8:int8、16:int16、32:int32、64:int64）// 返回转换后的结果和转换时遇到的错误// 如果 base 为 0，则根据字符串的前缀判断进位制（0x:16，0:8，其它:10）func ParseInt(s string, base int, bitSize int) (i int64, err error) 123456789101112131415func main() &#123; fmt.Println(strconv.ParseInt("123", 10, 8)) // 123 fmt.Println(strconv.ParseInt("12345", 10, 8)) // 127 strconv.ParseInt: parsing "12345": value out of range fmt.Println(strconv.ParseInt("2147483647", 10, 0)) // 2147483647 fmt.Println(strconv.ParseInt("0xFF", 16, 0)) // 0 strconv.ParseInt: parsing "0xFF": invalid syntax fmt.Println(strconv.ParseInt("FF", 16, 0)) // 255 fmt.Println(strconv.ParseInt("0xFF", 0, 0)) // 255&#125; // ParseUint 功能同 ParseInt 一样，只不过返回 uint 类型整数 func ParseUint(s string, base int, bitSize int) (n uint64, err error) 12345func main() &#123; fmt.Println(strconv.ParseUint("FF", 16, 8)) // 255&#125; // Atoi 相当于 ParseInt(s, 10, 0) // 通常使用这个函数，而不使用 ParseInt func Atoi(s string) (i int, err error) 123456func main() &#123; fmt.Println(strconv.Atoi("2147483647")) // 2147483647 fmt.Println(strconv.Atoi("2147483648")) // 2147483647 strconv.ParseInt: parsing "2147483648": value out of range&#125; // ftoa.go -———————————————————– // FormatFloat 将浮点数 f 转换为字符串值// f：要转换的浮点数// fmt：格式标记（b、e、E、f、g、G）// prec：精度（数字部分的长度，不包括指数部分）// bitSize：指定浮点类型（32:float32、64:float64）//// 格式标记：// ‘b’ (-ddddp±ddd，二进制指数)// ‘e’ (-d.dddde±dd，十进制指数)// ‘E’ (-d.ddddE±dd，十进制指数)// ‘f’ (-ddd.dddd，没有指数)// ‘g’ (‘e’:大指数，’f’:其它情况)// ‘G’ (‘E’:大指数，’f’:其它情况)//// 如果格式标记为 ‘e’，’E’和’f’，则 prec 表示小数点后的数字位数// 如果格式标记为 ‘g’，’G’，则 prec 表示总的数字位数（整数部分+小数部分）func FormatFloat(f float64, fmt byte, prec, bitSize int) string 12345678910111213141516171819202122232425262728293031323334package main import ( "fmt" "strconv") func main() &#123; f := 100.12345678901234567890123456789 fmt.Println(strconv.FormatFloat(f, 'b', 5, 32)) // 13123382p-17 fmt.Println(strconv.FormatFloat(f, 'e', 5, 32)) // 1.00123e+02 fmt.Println(strconv.FormatFloat(f, 'E', 5, 32)) // 1.00123E+02 fmt.Println(strconv.FormatFloat(f, 'f', 5, 32)) // 100.12346 fmt.Println(strconv.FormatFloat(f, 'g', 5, 32)) // 100.12 fmt.Println(strconv.FormatFloat(f, 'G', 5, 32)) // 100.12 fmt.Println(strconv.FormatFloat(f, 'b', 30, 32)) // 13123382p-17 fmt.Println(strconv.FormatFloat(f, 'e', 30, 32)) // 1.001234588623046875000000000000e+02 fmt.Println(strconv.FormatFloat(f, 'E', 30, 32)) // 1.001234588623046875000000000000E+02 fmt.Println(strconv.FormatFloat(f, 'f', 30, 32)) // 100.123458862304687500000000000000 fmt.Println(strconv.FormatFloat(f, 'g', 30, 32)) // 100.1234588623046875 fmt.Println(strconv.FormatFloat(f, 'G', 30, 32)) // 100.1234588623046875&#125; // AppendFloat 将浮点数 f 转换为字符串值，并将转换结果追加到 dst 的尾部 // 返回追加后的 []byte func AppendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int) []byte 12345678func main() &#123; f := 100.12345678901234567890123456789 b := make([]byte, 0) b = strconv.AppendFloat(b, f, 'f', 5, 32) b = append(b, " "...) b = strconv.AppendFloat(b, f, 'e', 5, 32) fmt.Printf("%s", b) // 100.12346 1.00123e+0&#125; // itoa.go -———————————————————– // FormatUint 将 int 型整数 i 转换为字符串形式// base：进位制（2 进制到 36 进制）// 大于 10 进制的数，返回值使用小写字母 ‘a’ 到 ‘z’func FormatInt(i int64, base int) string 123456789func main() &#123; i := int64(-2048) fmt.Println(strconv.FormatInt(i, 2)) // -100000000000 fmt.Println(strconv.FormatInt(i, 8)) // -4000 fmt.Println(strconv.FormatInt(i, 10)) // -2048 fmt.Println(strconv.FormatInt(i, 16)) // -800 fmt.Println(strconv.FormatInt(i, 36)) // -1kw&#125; // FormatUint 将 uint 型整数 i 转换为字符串形式// base：进位制（2 进制到 36 进制）// 大于 10 进制的数，返回值使用小写字母 ‘a’ 到 ‘z’func FormatUint(i uint64, base int) string 123456789func main() &#123; i := uint64(2048) fmt.Println(strconv.FormatUint(i, 2)) // 100000000000 fmt.Println(strconv.FormatUint(i, 8)) // 4000 fmt.Println(strconv.FormatUint(i, 10)) // 2048 fmt.Println(strconv.FormatUint(i, 16)) // 800 fmt.Println(strconv.FormatUint(i, 36)) // 1kw&#125; // Itoa 相当于 FormatInt(i, 10) func Itoa(i int) string 1234func main() &#123; fmt.Println(strconv.Itoa(-2048)) // -2048 fmt.Println(strconv.Itoa(2048)) // 2048&#125; // AppendInt 将 int 型整数 i 转换为字符串形式，并追加到 dst 的尾部 // i：要转换的字符串 // base：进位制 // 返回追加后的 []byte func AppendInt(dst []byte, i int64, base int) []byte 123456func main() &#123; b := make([]byte, 0) b = strconv.AppendInt(b, -2048, 16) fmt.Printf("%s", b) // -800&#125; // AppendUint 将 uint 型整数 i 转换为字符串形式，并追加到 dst 的尾部// i：要转换的字符串// base：进位制// 返回追加后的 []bytefunc AppendUint(dst []byte, i uint64, base int) []byte 12345func main() &#123; b := make([]byte, 0) b = strconv.AppendUint(b, 2048, 16) fmt.Printf("%s", b) // 800&#125; // quote.go -———————————————————– // Quote 将字符串 s 转换为“双引号”引起来的字符串 // 其中的特殊字符将被转换为“转义字符” // “不可显示的字符”将被转换为“转义字符” func Quote(s string) string 1234func main() &#123; fmt.Println(strconv.Quote(`C:\Windows`)) // "C:\\Windows"&#125; 注：此处是反引号（键盘上１左侧那个按键），而不是单引号 -———————————————————– // AppendQuote 将字符串 s 转换为“双引号”引起来的字符串， // 并将结果追加到 dst 的尾部，返回追加后的 []byte // 其中的特殊字符将被转换为“转义字符” func AppendQuote(dst []byte, s string) []byte 123456func main() &#123; s := `C:\Windows` b := make([]byte, 0) b = strconv.AppendQuote(b, s) fmt.Printf("%s", b) // "C:\\Windows"&#125; -———————————————————– // QuoteToASCII 将字符串 s 转换为“双引号”引起来的 ASCII 字符串 // “非 ASCII 字符”和“特殊字符”将被转换为“转义字符” func QuoteToASCII(s string) string 12345func main() &#123; fmt.Println(strconv.QuoteToASCII("Hello 世界！")) // "Hello \u4e16\u754c\uff01"&#125; -———————————————————– // AppendQuoteToASCII 将字符串 s 转换为“双引号”引起来的 ASCII 字符串， // 并将结果追加到 dst 的尾部，返回追加后的 []byte // “非 ASCII 字符”和“特殊字符”将被转换为“转义字符” func AppendQuoteToASCII(dst []byte, s string) []byte 123456func main() &#123; s := "Hello 世界！" b := make([]byte, 0) b = strconv.AppendQuoteToASCII(b, s) fmt.Printf("%s", b) // "Hello \u4e16\u754c\uff01"&#125; -———————————————————– // QuoteRune 将 Unicode 字符转换为“单引号”引起来的字符串 // “特殊字符”将被转换为“转义字符” func QuoteRune(r rune) string 1234func main() &#123; fmt.Println(strconv.QuoteRune('好')) // '好'&#125; 注：此处为单引号，而不是反引号，这要与Quote()使用去分开 // AppendQuoteRune 将 Unicode 字符转换为“单引号”引起来的字符串， // 并将结果追加到 dst 的尾部，返回追加后的 []byte // “特殊字符”将被转换为“转义字符” func AppendQuoteRune(dst []byte, r rune) []byte 123456func main() &#123; b := make([]byte, 0) b = strconv.AppendQuoteRune(b, '好') fmt.Printf("%s", b) // '好'&#125; -———————————————————– // QuoteRuneToASCII 将 Unicode 字符转换为“单引号”引起来的 ASCII 字符串 // “非 ASCII 字符”和“特殊字符”将被转换为“转义字符” func QuoteRuneToASCII(r rune) string 12345func main() &#123; fmt.Println(strconv.QuoteRuneToASCII('好')) // '\u597d'&#125; -———————————————————– // AppendQuoteRune 将 Unicode 字符转换为“单引号”引起来的 ASCII 字符串， // 并将结果追加到 dst 的尾部，返回追加后的 []byte // “非 ASCII 字符”和“特殊字符”将被转换为“转义字符” func AppendQuoteRuneToASCII(dst []byte, r rune) []byte 123456func main() &#123; b := make([]byte, 0) b = strconv.AppendQuoteRuneToASCII(b, '好') fmt.Printf("%s", b) // '\u597d'&#125; // CanBackquote 判断字符串 s 是否可以表示为一个单行的“反引号”字符串 // 字符串中不能含有控制字符（除了 \t）和“反引号”字符，否则返回 false func CanBackquote(s string) bool 123456789101112func main() &#123; b := strconv.CanBackquote("C:\\Windows\n") fmt.Println(b) // false b = strconv.CanBackquote("C:\\Windows\r") fmt.Println(b) // false b = strconv.CanBackquote("C:\\Windows\f") fmt.Println(b) // false b = strconv.CanBackquote("C:\\Windows\t") fmt.Println(b) // true b = strconv.CanBackquote("C:\\`Windows`") fmt.Println(b) // false&#125; // UnquoteChar 将 s 中的第一个字符“取消转义”并解码 // // s：转义后的字符串 // quote：字符串使用的“引号符”（用于对引号符“取消转义”） // // value： 解码后的字符 // multibyte：value 是否为多字节字符 // tail： 字符串 s 除去 value 后的剩余部分 // error： 返回 s 中是否存在语法错误 // // 参数 quote 为“引号符” // 如果设置为单引号，则 s 中允许出现 \’ 字符，不允许出现单独的 ‘ 字符 // 如果设置为双引号，则 s 中允许出现 \” 字符，不允许出现单独的 “ 字符 // 如果设置为 0，则不允许出现 \’ 或 \” 字符，可以出现单独的 ‘ 或 “ 字符 func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error) 12345678910111213141516func main() &#123; s := `\"大\\家\\好！\"` c, mb, sr, _ := strconv.UnquoteChar(s, '"') fmt.Printf("%-3c %v\n", c, mb) for ; len(sr) &gt; 0; c, mb, sr, _ = strconv.UnquoteChar(sr, '"') &#123; fmt.Printf("%-3c %v\n", c, mb) &#125; // " false // 大 true // \ false // 家 true // \ false // 好 true // ！ true&#125; // Unquote 将“带引号的字符串” s 转换为常规的字符串（不带引号和转义字符） // s 可以是“单引号”、“双引号”或“反引号”引起来的字符串（包括引号本身） // 如果 s 是单引号引起来的字符串，则返回该该字符串代表的字符 func Unquote(s string) (t string, err error) 12345678910func main() &#123; sr, err := strconv.Unquote(`"\"大\t家\t好！\""`) fmt.Println(sr, err) sr, err = strconv.Unquote(`'大家好！'`) fmt.Println(sr, err) sr, err = strconv.Unquote(`'好'`) fmt.Println(sr, err) sr, err = strconv.Unquote("`大\\t家\\t好！`") fmt.Println(sr, err)&#125; -———————————————————– // IsPrint 判断 Unicode 字符 r 是否是一个可显示的字符 // 可否显示并不是你想象的那样，比如空格可以显示，而\t则不能显示 // 具体可以参考 Go 语言的源码 func IsPrint(r rune) bool 12345678func main() &#123; fmt.Println(strconv.IsPrint('a')) // true fmt.Println(strconv.IsPrint('好')) // true fmt.Println(strconv.IsPrint(' ')) // true fmt.Println(strconv.IsPrint('\t')) // false fmt.Println(strconv.IsPrint('\n')) // false fmt.Println(strconv.IsPrint(0)) // false&#125;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fmt 包中的函数和方法]]></title>
    <url>%2F2019%2F05%2F22%2Ffmt%20%E5%8C%85%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[fmt 包中的函数和方法 // Print 将参数列表 a 中的各个参数转换为字符串并写入到标准输出中。// 非字符串参数之间会添加空格，返回写入的字节数。func Print(a …interface{}) (n int, err error) // Println 功能类似 Print，只不过最后会添加一个换行符。// 所有参数之间会添加空格，返回写入的字节数。func Println(a …interface{}) (n int, err error) // Printf 将参数列表 a 填写到格式字符串 format 的占位符中。// 填写后的结果写入到标准输出中，返回写入的字节数。func Printf(format string, a …interface{}) (n int, err error) // 功能同上面三个函数，只不过将转换结果写入到 w 中。func Fprint(w io.Writer, a …interface{}) (n int, err error)func Fprintln(w io.Writer, a …interface{}) (n int, err error)func Fprintf(w io.Writer, format string, a …interface{}) (n int, err error) // 功能同上面三个函数，只不过将转换结果以字符串形式返回。func Sprint(a …interface{}) stringfunc Sprintln(a …interface{}) stringfunc Sprintf(format string, a …interface{}) string // 功能同 Sprintf，只不过结果字符串被包装成了 error 类型。func Errorf(format string, a …interface{}) error 123456789101112131415161718192021222324252627// 示例func main() &#123; fmt.Print("a", "b", 1, 2, 3, "c", "d", "\n") fmt.Println("a", "b", 1, 2, 3, "c", "d") fmt.Printf("ab %d %d %d cd\n", 1, 2, 3) // ab1 2 3cd // a b 1 2 3 c d // ab 1 2 3 cd if err := percent(30, 70, 90, 160); err != nil &#123; fmt.Println(err) &#125; // 30% // 70% // 90% // 数值 160 超出范围（100）&#125;func percent(i ...int) error &#123; for _, n := range i &#123; if n &gt; 100 &#123; return fmt.Errorf("数值 %d 超出范围（100）", n) &#125; fmt.Print(n, "%\n") &#125; return nil&#125; // Formatter 由自定义类型实现，用于实现该类型的自定义格式化过程。// 当格式化器需要格式化该类型的变量时，会调用其 Format 方法。type Formatter interface { // f 用于获取占位符的旗标、宽度、精度等信息，也用于输出格式化的结果 // c 是占位符中的动词 Format(f State, c rune)} // 由格式化器（Print 之类的函数）实现，用于给自定义格式化过程提供信息type State interface { // Formatter 通过 Write 方法将格式化结果写入格式化器中，以便输出。 Write(b []byte) (ret int, err error) // Formatter 通过 Width 方法获取占位符中的宽度信息及其是否被设置。 Width() (wid int, ok bool) // Formatter 通过 Precision 方法获取占位符中的精度信息及其是否被设置。 Precision() (prec int, ok bool) // Formatter 通过 Flag 方法获取占位符中的旗标[+- 0#]是否被设置。 Flag(c int) bool} // Stringer 由自定义类型实现，用于实现该类型的自定义格式化过程。// 当格式化器需要输出该类型的字符串格式时就会调用其 String 方法。type Stringer interface { String() string} // Stringer 由自定义类型实现，用于实现该类型的自定义格式化过程。// 当格式化器需要输出该类型的 Go 语法字符串（%#v）时就会调用其 String 方法。type GoStringer interface { GoString() string} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 示例type Ustr stringfunc (us Ustr) String() string &#123; return strings.ToUpper(string(us))&#125;func (us Ustr) GoString() string &#123; return `"` + strings.ToUpper(string(us)) + `"`&#125;func (u Ustr) Format(f fmt.State, c rune) &#123; write := func(s string) &#123; f.Write([]byte(s)) &#125; switch c &#123; case 'm', 'M': write("旗标：[") for s := "+- 0#"; len(s) &gt; 0; s = s[1:] &#123; if f.Flag(int(s[0])) &#123; write(s[:1]) &#125; &#125; write("]") if v, ok := f.Width(); ok &#123; write(" | 宽度：" + strconv.FormatInt(int64(v), 10)) &#125; if v, ok := f.Precision(); ok &#123; write(" | 精度：" + strconv.FormatInt(int64(v), 10)) &#125; case 's', 'v': // 如果使用 Format 函数，则必须自己处理所有格式，包括 %#v if c == 'v' &amp;&amp; f.Flag('#') &#123; write(u.GoString()) &#125; else &#123; write(u.String()) &#125; default: // 如果使用 Format 函数，则必须自己处理默认输出 write("无效格式：" + string(c)) &#125;&#125;func main() &#123; u := Ustr("Hello World!") // "-" 标记和 "0" 标记不能同时存在 fmt.Printf("%-+ 0#8.5m\n", u) // 旗标：[+- #] | 宽度：8 | 精度：5 fmt.Printf("%+ 0#8.5M\n", u) // 旗标：[+ 0#] | 宽度：8 | 精度：5 fmt.Println(u) // HELLO WORLD! fmt.Printf("%s\n", u) // HELLO WORLD! fmt.Printf("%#v\n", u) // "HELLO WORLD!" fmt.Printf("%d\n", u) // 无效格式：d&#125; // Scan 从标准输入中读取数据，并将数据用空白分割并解析后存入 a 提供// 的变量中（换行符会被当作空白处理），变量必须以指针传入。// 当读到 EOF 或所有变量都填写完毕则停止扫描。// 返回成功解析的参数数量。func Scan(a …interface{}) (n int, err error) // Scanln 和 Scan 类似，只不过遇到换行符就停止扫描。func Scanln(a …interface{}) (n int, err error) // Scanf 从标准输入中读取数据，并根据格式字符串 format 对数据进行解析，// 将解析结果存入参数 a 所提供的变量中，变量必须以指针传入。// 输入端的换行符必须和 format 中的换行符相对应（如果格式字符串中有换行// 符，则输入端必须输入相应的换行符）。// 占位符 %c 总是匹配下一个字符，包括空白，比如空格符、制表符、换行符。// 返回成功解析的参数数量。func Scanf(format string, a …interface{}) (n int, err error) // 功能同上面三个函数，只不过从 r 中读取数据。func Fscan(r io.Reader, a …interface{}) (n int, err error)func Fscanln(r io.Reader, a …interface{}) (n int, err error)func Fscanf(r io.Reader, format string, a …interface{}) (n int, err error) // 功能同上面三个函数，只不过从 str 中读取数据。func Sscan(str string, a …interface{}) (n int, err error)func Sscanln(str string, a …interface{}) (n int, err error)func Sscanf(str string, format string, a …interface{}) (n int, err error) 12345678910111213141516171819202122232425262728// 示例// 对于 Scan 而言，回车视为空白func main() &#123; a, b, c := "", 0, false fmt.Scan(&amp;a, &amp;b, &amp;c) fmt.Println(a, b, c) // 在终端执行后，输入 abc 1 回车 true 回车 // 结果 abc 1 true&#125;// 对于 Scanln 而言，回车结束扫描func main() &#123; a, b, c := "", 0, false fmt.Scanln(&amp;a, &amp;b, &amp;c) fmt.Println(a, b, c) // 在终端执行后，输入 abc 1 true 回车 // 结果 abc 1 true&#125;// 格式字符串可以指定宽度func main() &#123; a, b, c := "", 0, false fmt.Scanf("%4s%d%t", &amp;a, &amp;b, &amp;c) fmt.Println(a, b, c) // 在终端执行后，输入 1234567true 回车 // 结果 1234 567 true&#125; // Scanner 由自定义类型实现，用于实现该类型的自定义扫描过程。// 当扫描器需要解析该类型的数据时，会调用其 Scan 方法。type Scanner interface { // state 用于获取占位符中的宽度信息，也用于从扫描器中读取数据进行解析。 // verb 是占位符中的动词 Scan(state ScanState, verb rune) error} // 由扫描器（Scan 之类的函数）实现，用于给自定义扫描过程提供数据和信息。type ScanState interface { // ReadRune 从扫描器中读取一个字符，如果用在 Scanln 类的扫描器中， // 则该方法会在读到第一个换行符之后或读到指定宽度之后返回 EOF。 // 返回“读取的字符”和“字符编码所占用的字节数” ReadRune() (r rune, size int, err error) // UnreadRune 撤消最后一次的 ReadRune 操作， // 使下次的 ReadRune 操作得到与前一次 ReadRune 相同的结果。 UnreadRune() error // SkipSpace 为 Scan 方法提供跳过开头空白的能力。 // 根据扫描器的不同（Scan 或 Scanln）决定是否跳过换行符。 SkipSpace() // Token 用于从扫描器中读取符合要求的字符串， // Token 从扫描器中读取连续的符合 f(c) 的字符 c，准备解析。 // 如果 f 为 nil，则使用 !unicode.IsSpace(c) 代替 f(c)。 // skipSpace：是否跳过开头的连续空白。返回读取到的数据。 // 注意：token 指向共享的数据，下次的 Token 操作可能会覆盖本次的结果。 Token(skipSpace bool, f func(rune) bool) (token []byte, err error) // Width 返回占位符中的宽度值以及宽度值是否被设置 Width() (wid int, ok bool) // 因为上面实现了 ReadRune 方法，所以 Read 方法永远不应该被调用。 // 一个好的 ScanState 应该让 Read 直接返回相应的错误信息。 Read(buf []byte) (n int, err error)} 123456789101112131415161718192021222324252627282930313233// 示例type Ustr stringfunc (u *Ustr) Scan(state fmt.ScanState, verb rune) (err error) &#123; var s []byte switch verb &#123; case 'S': s, err = state.Token(true, func(c rune) bool &#123; return 'A' &lt;= c &amp;&amp; c &lt;= 'Z' &#125;) if err != nil &#123; return &#125; case 's', 'v': s, err = state.Token(true, func(c rune) bool &#123; return 'a' &lt;= c &amp;&amp; c &lt;= 'z' &#125;) if err != nil &#123; return &#125; default: return fmt.Errorf("无效格式：%c", verb) &#125; *u = Ustr(s) return nil&#125;func main() &#123; var a, b, c, d, e Ustr n, err := fmt.Scanf("%3S%S%3s%2v%x", &amp;a, &amp;b, &amp;c, &amp;d, &amp;e) fmt.Println(a, b, c, d, e) fmt.Println(n, err) // 在终端执行后，输入 ABCDEFGabcdefg 回车 // 结果： // ABC DEFG abc de // 4 无效格式：x&#125;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go-redis 学习指南]]></title>
    <url>%2F2019%2F05%2F18%2FGolang%20redis%20%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[go-redis 学习指南安装我使用的是 https://github.com/go-redis/r… 这个 golang 客户端, 因此安装方式如下: go get gopkg.in/redis.v4 接着在代码中导入此包即可: import “gopkg.in/redis.v4” 基本操作创建客户端通过 redis.NewClient 函数即可创建一个 redis 客户端, 这个方法接收一个 redis.Options 对象参数, 通过这个参数, 我们可以配置 redis 相关的属性, 例如 redis 服务器地址, 数据库名, 数据库密码等. 下面是一个连接的例子: 1234567891011121314// 创建 redis 客户端func createClient() *redis.Client &#123; client := redis.NewClient(&amp;redis.Options&#123; Addr: "localhost:6379", Password: "", DB: 0, &#125;) // 通过 cient.Ping() 来检查是否成功连接到了 redis 服务器 pong, err := client.Ping().Result() fmt.Println(pong, err) return client&#125; String 操作redis 的 String 操作有: 123456789101112131415161718192021222324252627set(key, value)：给数据库中名称为key的string赋予值valueget(key)：返回数据库中名称为key的string的valuegetset(key, value)：给名称为key的string赋予上一次的valuemget(key1, key2,…, key N)：返回库中多个string的valuesetnx(key, value)：添加string，名称为key，值为valuesetex(key, time, value)：向库中添加string，设定过期时间timemset(key N, value N)：批量设置多个string的值msetnx(key N, value N)：如果所有名称为key i的string都不存在incr(key)：名称为key的string增1操作incrby(key, integer)：名称为key的string增加integerdecr(key)：名称为key的string减1操作decrby(key, integer)：名称为key的string减少integerappend(key, value)：名称为key的string的值附加valuesubstr(key, start, end)：返回名称为key的string的value的子串 在 go-redis 中, 我们可以直接找到对应的操作方法, 直接上代码: 12345678910111213141516171819202122232425262728293031323334353637383940// String 操作func stringOperation(client *redis.Client) &#123; // 第三个参数是过期时间, 如果是0, 则表示没有过期时间. err := client.Set("name", "xys", 0).Err() if err != nil &#123; panic(err) &#125; val, err := client.Get("name").Result() if err != nil &#123; panic(err) &#125; fmt.Println("name", val) // 这里设置过期时间. err = client.Set("age", "20", 1 * time.Second).Err() if err != nil &#123; panic(err) &#125; client.Incr("age") // 自增 client.Incr("age") // 自增 client.Decr("age") // 自减 val, err = client.Get("age").Result() if err != nil &#123; panic(err) &#125; fmt.Println("age", val) // age 的值为21 // 因为 key "age" 的过期时间是一秒钟, 因此当一秒后, 此 key 会自动被删除了. time.Sleep(1 * time.Second) val, err = client.Get("age").Result() if err != nil &#123; // 因为 key "age" 已经过期了, 因此会有一个 redis: nil 的错误. fmt.Printf("error: %v\n", err) &#125; fmt.Println("age", val)&#125; list 操作redis 的 list 操作有: 12345678910111213141516171819202122232425rpush(key, value)：在名称为key的list尾添加一个值为value的元素lpush(key, value)：在名称为key的list头添加一个值为value的 元素llen(key)：返回名称为key的list的长度lrange(key, start, end)：返回名称为key的list中start至end之间的元素ltrim(key, start, end)：截取名称为key的listlindex(key, index)：返回名称为key的list中index位置的元素lset(key, index, value)：给名称为key的list中index位置的元素赋值lrem(key, count, value)：删除count个key的list中值为value的元素lpop(key)：返回并删除名称为key的list中的首元素rpop(key)：返回并删除名称为key的list中的尾元素blpop(key1, key2,… key N, timeout)：lpop命令的block版本。brpop(key1, key2,… key N, timeout)：rpop的block版本。rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部 同样地, 在 go-redis 中也可以找到对应的方法, 下面是一个简单的示例: 123456789101112131415161718192021222324252627// list 操作func listOperation(client *redis.Client) &#123; client.RPush("fruit", "apple") //在名称为 fruit 的list尾添加一个值为value的元素 client.LPush("fruit", "banana") //在名称为 fruit 的list头添加一个值为value的 元素 length, err := client.LLen("fruit").Result() //返回名称为 fruit 的list的长度 if err != nil &#123; panic(err) &#125; fmt.Println("length: ", length) // 长度为2 value, err := client.LPop("fruit").Result() //返回并删除名称为 fruit 的list中的首元素 if err != nil &#123; panic(err) &#125; fmt.Println("fruit: ", value) value, err = client.RPop("fruit").Result() // 返回并删除名称为 fruit 的list中的尾元素 if err != nil &#123; panic(err) &#125; fmt.Println("fruit: ", value)&#125; set 操作redis 的 set 操作: 123456789101112131415161718192021222324252627sadd(key, member)：向名称为key的set中添加元素membersrem(key, member) ：删除名称为key的set中的元素memberspop(key) ：随机返回并删除名称为key的set中一个元素smove(srckey, dstkey, member) ：移到集合元素scard(key) ：返回名称为key的set的基数sismember(key, member) ：member是否是名称为key的set的元素sinter(key1, key2,…key N) ：求交集sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合sunion(key1, (keys)) ：求并集sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合sdiff(key1, (keys)) ：求差集sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合smembers(key) ：返回名称为key的set的所有元素srandmember(key) ：随机返回名称为key的set的一个元素 接下来是 go-redis 的 set 操作: 1234567891011121314151617181920212223242526272829303132// set 操作func setOperation(client *redis.Client) &#123; client.SAdd("blacklist", "Obama") // 向 blacklist 中添加元素 client.SAdd("blacklist", "Hillary") // 再次添加 client.SAdd("blacklist", "the Elder") // 添加新元素 client.SAdd("whitelist", "the Elder") // 向 whitelist 添加元素 // 判断元素是否在集合中 isMember, err := client.SIsMember("blacklist", "Bush").Result() if err != nil &#123; panic(err) &#125; fmt.Println("Is Bush in blacklist: ", isMember) // 求交集, 即既在黑名单中, 又在白名单中的元素 names, err := client.SInter("blacklist", "whitelist").Result() if err != nil &#123; panic(err) &#125; // 获取到的元素是 "the Elder" fmt.Println("Inter result: ", names) // 获取指定集合的所有元素 all, err := client.SMembers("blacklist").Result() if err != nil &#123; panic(err) &#125; fmt.Println("All member: ", all)&#125; hash 操作redis 的 hash 操作: 123456789101112131415161718192021hset(key, field, value)：向名称为key的hash中添加元素fieldhget(key, field)：返回名称为key的hash中field对应的valuehmget(key, (fields))：返回名称为key的hash中field i对应的valuehmset(key, (fields))：向名称为key的hash中添加元素field hincrby(key, field, integer)：将名称为key的hash中field的value增加integerhexists(key, field)：名称为key的hash中是否存在键为field的域hdel(key, field)：删除名称为key的hash中键为field的域hlen(key)：返回名称为key的hash中元素个数hkeys(key)：返回名称为key的hash中所有键hvals(key)：返回名称为key的hash中所有键对应的valuehgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value go-redis 中的 hash 操作: 12345678910111213141516171819202122232425262728293031// hash 操作func hashOperation(client *redis.Client) &#123; client.HSet("user_xys", "name", "xys"); // 向名称为 user_xys 的 hash 中添加元素 name client.HSet("user_xys", "age", "18"); // 向名称为 user_xys 的 hash 中添加元素 age // 批量地向名称为 user_test 的 hash 中添加元素 name 和 age client.HMSet("user_test", map[string]string&#123;"name": "test", "age":"20"&#125;) // 批量获取名为 user_test 的 hash 中的指定字段的值. fields, err := client.HMGet("user_test", "name", "age").Result() if err != nil &#123; panic(err) &#125; fmt.Println("fields in user_test: ", fields) // 获取名为 user_xys 的 hash 中的字段个数 length, err := client.HLen("user_xys").Result() if err != nil &#123; panic(err) &#125; fmt.Println("field count in user_xys: ", length) // 字段个数为2 // 删除名为 user_test 的 age 字段 client.HDel("user_test", "age") age, err := client.HGet("user_test", "age").Result() if err != nil &#123; fmt.Printf("Get user_test age error: %v\n", err) &#125; else &#123; fmt.Println("user_test age is: ", age) // 字段个数为2 &#125;&#125; 关于连接池redis.v4 包实现了 redis 的连接池管理, 因此我们就不需要自己手动管理 redis 的连接了. 默认情况下, redis.v4 的 redis 连接池大小是10, 不过我们可以在初始化 redis 客户端时自行设置连接池的大小, 例如: 123456client := redis.NewClient(&amp;redis.Options&#123; Addr: "localhost:6379", Password: "", DB: 0, PoolSize: 5,&#125;) 通过 redis.Options 的 PoolSize 属性, 我们设置了 redis 连接池的大小为5. 那么接下来我们来看一下这个设置有什么效果吧: 1234567891011121314151617181920// redis.v4 的连接池管理func connectPool(client *redis.Client) &#123; wg := sync.WaitGroup&#123;&#125; wg.Add(10) for i := 0; i &lt; 10; i++ &#123; go func() &#123; defer wg.Done() for j := 0; j &lt; 100; j++ &#123; client.Set(fmt.Sprintf("name%d", j), fmt.Sprintf("xys%d", j), 0).Err() client.Get(fmt.Sprintf("name%d", j)).Result() &#125; fmt.Printf("PoolStats, TotalConns: %d, FreeConns: %d\n", client.PoolStats().TotalConns, client.PoolStats().FreeConns); &#125;() &#125; wg.Wait()&#125; 上面的例子启动了10个 routine 来不断向 redis 读写数据, 然后我们通过 client.PoolStats() 获取连接池的信息. 运行这个例子, 输出如下: 12345678910111213141516171819PoolStats, TotalConns: 5, FreeConns: 1PoolStats, TotalConns: 5, FreeConns: 1PoolStats, TotalConns: 5, FreeConns: 1PoolStats, TotalConns: 5, FreeConns: 1PoolStats, TotalConns: 5, FreeConns: 1PoolStats, TotalConns: 5, FreeConns: 2PoolStats, TotalConns: 5, FreeConns: 2PoolStats, TotalConns: 5, FreeConns: 3PoolStats, TotalConns: 5, FreeConns: 4PoolStats, TotalConns: 5, FreeConns: 5 通过输出可以看到, 此时最大的连接池数量确实是 5 了, 并且一开始时, 因为 coroutine 的数量大于5, 会造成 redis 连接不足的情况(反映在 FreeConns 上就是前几次的输出 FreeConns 一直是1), 当某个 coroutine 结束后, 会释放此 redis 连接, 因此 FreeConns 会增加. 主函数123456789101112131415161718192021package mainimport ( "fmt" "gopkg.in/redis.v4" "time" "sync")func main() &#123; client := createClient() defer client.Close() stringOperation(client) listOperation(client) setOperation(client) hashOperation(client) connectPool(client)&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 操作 Redis]]></title>
    <url>%2F2019%2F05%2F18%2FGolang%20%E6%93%8D%E4%BD%9C%20Redis%2F</url>
    <content type="text"><![CDATA[Golang 操作 Redis安装第三方开源 Redis 库1) 使用第三方开源的 redis 库: github.com/garyburd/redigo/redis 2) 在使用 Redis 前，先安装第三方 Redis 库，在 GOPATH 路径下执行安装指令: ​ go get github.com/garyburd/redigo/redis Set/Get 接口1234567891011121314151617181920212223242526272829303132package main import ( "fmt" "github.com/garyburd/redigo/redis" //引入 redis 包)func main() &#123; //通过 go 向 redis 写入数据和读取数据 //1. 链接到 redis conn, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("redis.Dial err=", err) return&#125; defer conn.Close() //关闭.. //2. 通过 go 向 redis 写入数据 string [key-val] _, err = conn.Do("Set", "name", "tomjerry 猫猫") if err != nil &#123; fmt.Println("set err=", err) return &#125; //3. 通过 go 向 redis 读取数据 string [key-val] r, err := redis.String(conn.Do("Get", "name")) if err != nil &#123; fmt.Println("set err=", err) return &#125; //因为 conn.Do 返回 interface&#123;&#125; fmt.Println("操作 ok ", r)&#125; 操作 Hash说明: 通过 Golang 对 Redis 操作 Hash 数据类型 对 hash 数据结构，field-val 是一个一个放入和读取 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package main import ( "fmt" "github.com/garyburd/redigo/redis" //引入 redis 包)func main() &#123; //通过 go 向 redis 写入数据和读取数据 //1. 链接到 redis conn, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("redis.Dial err=", err) return &#125; defer conn.Close() //关闭.. //2. 通过 go 向 redis 写入数据 string [key-val] _, err = conn.Do("HSet", "user01", "name", "john") if err != nil &#123; fmt.Println("hset err=", err) return &#125; _, err = conn.Do("HSet", "user01", "age", 18) if err != nil &#123; fmt.Println("hset err=", err) return &#125; //3. 通过 go 向 redis 读取数据 r1, err := redis.String(conn.Do("HGet","user01", "name")) if err != nil &#123; fmt.Println("hget err=", err) return &#125; r2, err := redis.Int(conn.Do("HGet","user01", "age")) if err != nil &#123; fmt.Println("hget err=", err) return &#125; fmt.Printf("操作 ok r1=%v r2=%v \n", r1, r2)&#125; 批量写入hash 123456789101112131415161718192021222324252627282930313233package main import ( "fmt" "github.com/garyburd/redigo/redis" //引入 redis 包)func main() &#123; //通过 go 向 redis 写入数据和读取数据 //1. 链接到 redis conn, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("redis.Dial err=", err) return &#125; defer conn.Close() //关闭.. //2. 通过 go 向 redis 写入数据 string [key-val] _, err = conn.Do("HMSet", "user02", "name", "john", "age", 19) if err != nil &#123; fmt.Println("HMSet err=", err) return &#125; //3. 通过 go 向 redis 读取数据 r, err := redis.Strings(conn.Do("HMGet","user02", "name", "age")) if err != nil &#123; fmt.Println("hget err=", err) return &#125; for i, v := range r &#123; fmt.Printf("r[%d]=%s\n", i, v) &#125;&#125; 批量 Set/Get 数据说明: 通过 Golang 对 Redis 操作，一次操作可以 Set / Get 多个 key-val 数据 核心代码: 12345_, err = c.Do("MSet", "name", "尚硅谷", "address", "北京昌平~")r, err := redis.Strings(c.Do("MGet", "name", "address"))for _, v := range r &#123; fmt.Println(v)&#125; 给数据设置有效时间说明: 通过 Golang 对 Redis 操作，给 key-value 设置有效时间 核心代码: 12//给 name 数据设置有效时间为 10s_, err = c.Do("expire", "name", 10) 操作 List说明: 通过 Golang 对 Redis 操作 List 数据类型 核心代码: 12_, err = c.Do("lpush", "heroList", "no1:宋江", 30, "no2:卢俊义", 28) r, err := redis.String(c.Do("rpop", "heroList")) 总结基本流程： 1234567891011121314151617181920212223242526272829303132333435//1.首先导入相应的Redis包package main import ( "fmt" "github.com/garyburd/redigo/redis" //引入 redis 包)func main() &#123; //通过 go 向 redis 写入数据和读取数据 //2. 链接到 redis conn, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("redis.Dial err=", err) return &#125; defer conn.Close() //关闭.. //3. 通过 go 操作 redis 读取数据 // conn.Do("commandName",args) _, err = conn.Do("HMSet", "user02", "name", "john", "age", 19) if err != nil &#123; fmt.Println("HMSet err=", err) return &#125; //4. 通过 go 向 redis 读取数据 先读取，再转换成相应类型 //redis.Type(conn.Do("commandName",args) ) r, err := redis.Strings(conn.Do("HMGet","user02", "name", "age")) if err != nil &#123; fmt.Println("hget err=", err) return &#125; for i, v := range r &#123; fmt.Printf("r[%d]=%s\n", i, v) &#125;&#125; Redis 链接池说明: 通过 Golang 对 Redis 操作， 还可以通过 Redis 链接池, 流程如下： 1) 事先初始化一定数量的链接，放入到链接池 2) 当 Go 需要操作 Redis 时，直接从 Redis 链接池取出链接即可。 3) 这样可以节省临时获取 Redis 链接的时间，从而提高效率. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport ( "fmt" "github.com/garyburd/redigo/redis")//定义一个全局的poolvar pool *redis.Pool//当启动程序时，就初始化连接池func init() &#123; pool = &amp;redis.Pool&#123; MaxIdle: 8, //最大空闲链接数 MaxActive: 0, // 表示和数据库的最大链接数， 0 表示没有限制 IdleTimeout: 100, // 最大空闲时间 Dial: func() (redis.Conn, error) &#123; // 初始化链接的代码， 链接哪个 ip 的 redis return redis.Dial("tcp", "127.0.0.1:6379") &#125;, &#125;&#125;func main() &#123; //先从 pool 取出一个链接 conn := pool.Get() defer conn.Close() _, err := conn.Do("Set", "name", "abc") if err != nil &#123; fmt.Println("conn.Do err=", err) return &#125; //取出 r, err := redis.String(conn.Do("Get", "name")) if err != nil &#123; fmt.Println("conn.Do err=", err) return &#125; fmt.Println("r=", r) //如果我们要从 pool 取出链接，一定保证链接池是没有关闭 //pool.Close() conn2 := pool.Get() _, err = conn2.Do("Set", "name2", "汤姆猫~~2") if err != nil &#123; fmt.Println("conn.Do err~~~~=", err) return &#125; //取出 r2, err := redis.String(conn2.Do("Get", "name2")) if err != nil &#123; fmt.Println("conn.Do err=", err) return &#125; fmt.Println("r=", r2) //fmt.Println("conn2=", conn2) &#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 基本使用]]></title>
    <url>%2F2019%2F05%2F16%2FRedis%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Redis 基本使用基本介绍Redis是一种NoSQL数据库 官网: http://redis.io/ 和 http://www.redis.cn/ Redis 在Windows下安装但是Redis不再支持Windows，所以去Github上下载微软支持版本 https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100 有两种版本 .msi是安装版本 .zip是已经编译版本 此次采用的第二种： 解压后的文件目录 其中redis-server.exe 是服务器端，需要一直开启。但是网上有另外一种安装服务的方法。 redis-cli.exe 是客户端命令行 redis.windows.conf 是配置文件 redis-benchmark：Redis性能测试工具，测试Redis在你的系统及你的配置下的读写性能。 安装Redis服务的方法1234#安装redis-server --service-install redis.windows.conf#启动redis-server --service-start Redis的基本使用命令参考：http://redisdoc.com 打开redis-cli.exe Redis的CRUDRedis的五大数据类型 String（字符串），Hash（哈希），List（列表），Set（集合），zset（sorted set：有序集合） String类型string是基本类型 key与value 一一对应 set[如果存在就相当于修改，不存在就是添加]/get/del setex(set with expire)键秒值 mset[同时设置一个或多个 key-value 对] mget[同时获取多个 key-val] Hash (哈希，类似 golang 里的 Map)类型Redis hash 是一个键值对集合。var user1 map[string]string Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 hset/hget/hgetall/hdel 使用 hmset 和 hmget 可以一次性来设置多个 filed 的值和返回多个 field 的值 hlen 统计一个 hash 有几个元素. hexists key field， 查看哈希表 key 中，给定域 field 是否存在 List（列表）类型列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 List 本质是个链表, List 的元素 是有序的，元素的值可以重复 lpush/rpush/lrange/lpop/rpop/del Set（集合）类型Redis 的 Set 是 string 类型的无序集合 底层是 HashTable 数据结构, Set 也是存放很多字符串元素，字符串元素是无序的，而且元素的值不能重复 sadd/smembers[取出所有值]/sismember[判断值是否是成员] /srem [删除指定值]]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Quick Intro]]></title>
    <url>%2F2019%2F05%2F16%2FSQL%20Quick%20Intro%2F</url>
    <content type="text"><![CDATA[SQL Quick Intro基本用法12345678910111213//SQL基本用法select area form table_name where conditionupdate table_name set area = value where conditiondelete from table where conditionINSERT INTO 表名称 VALUES (值1, 值2,....)INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)drop table/database//清空数据TRUNCATE TABLE 表名称 SQL关键字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//关键字and/ or /notorder by desc asclike pattern //其中通配符 %为替代多个 _替代一个 [charlist] 其中任何一个 [！charlist] 不是其中任何一个in(val1,val2,...)between val1 and val2 //表的 SQL Alias 语法SELECT column_name(s)FROM table_nameAS alias_name列的 SQL Alias 语法SELECT column_name AS alias_nameFROM table_name//SQL UNION 语法 加上ALL允许重复值SELECT column_name(s) FROM table_name1UNION(ALL)SELECT column_name(s) FROM table_name2//SQL SELECT INTO 语法SELECT column_name(s)INTO new_table_name [IN externaldatabase] FROM old_tablename//SQL CREATE DATABASE 语法CREATE DATABASE database_name//SQL CREATE TABLE 语法CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,....)//SQL GROUP BY 语法SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name//SQL HAVING 语法SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_nameHAVING aggregate_function(column_name) operator value SQL Join()用法可以使用的 JOIN 类型，以及它们之间的差异。 JOIN（INNER JOIN）: 如果表中有至少一个匹配，则返回行LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行FULL JOIN: 只要其中一个表中存在匹配，就返回行 123456//JOIN 关键字语法SELECT column_name(s)FROM table_name1（XX）JOIN table_name2 ON table_name1.column_name=table_name2.column_name SQL数据类型 数据类型 描述 integer(size)int(size)smallint(size)tinyint(size) 仅容纳整数。在括号内规定数字的最大位数。 decimal(size,d)numeric(size,d) 容纳带有小数的数字。”size” 规定数字的最大位数。”d” 规定小数点右侧的最大位数。 char(size) 容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。在括号中规定字符串的长度。 varchar(size) 容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。在括号中规定字符串的最大长度。 date(yyyymmdd) 容纳日期。 SQL 约束约束用于限制加入表的数据的类型。 可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）。 我们将主要探讨以下几种约束： NOT NULL UNIQUE PRIMARY KEY FOREIGN KEY CHECK DEFAULT SQL函数 函数 描述 AVG(column) 返回某列的平均值 BINARY_CHECKSUM CHECKSUM CHECKSUM_AGG COUNT(column) 返回某列的行数（不包括NULL值） COUNT(*) 返回被选行数 COUNT(DISTINCT column) 返回相异结果的数目 FIRST(column) 返回在指定的域中第一个记录的值（SQLServer2000 不支持） LAST(column) 返回在指定的域中最后一个记录的值（SQLServer2000 不支持） MAX(column) 返回某列的最高值 MIN(column) 返回某列的最低值 STDEV(column) STDEVP(column) SUM(column) 返回某列的总和 VAR(column) VARP(column) SQL 语句速查 语句 语法 AND / OR SELECT column_name(s) FROM table_name WHERE condition AND\OR condition ALTER TABLE (add column) ALTER TABLE table_name ADD column_name datatype ALTER TABLE (drop column) ALTER TABLE table_name DROP COLUMN column_name AS (alias for column) SELECT column_name AS column_alias FROM table_name AS (alias for table) SELECT column_name FROM table_name AS table_alias BETWEEN SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2 CREATE DATABASE CREATE DATABASE database_name CREATE INDEX CREATE INDEX index_name ON table_name (column_name) CREATE TABLE CREATE TABLE table_name ( column_name1 data_type, column_name2 data_type, ……. ) CREATE UNIQUE INDEX CREATE UNIQUE INDEX index_name ON table_name (column_name) CREATE VIEW CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition DELETE FROM DELETE FROM table_name (Note: Deletes the entire table!!)orDELETE FROM table_name WHERE condition DROP DATABASE DROP DATABASE database_name DROP INDEX DROP INDEX table_name.index_name DROP TABLE DROP TABLE table_name GROUP BY SELECT column_name1,SUM(column_name2) FROM table_name GROUP BY column_name1 HAVING SELECT column_name1,SUM(column_name2) FROM table_name GROUP BY column_name1 HAVING SUM(column_name2) condition value IN SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,..) INSERT INTO INSERT INTO table_name VALUES (value1, value2,….)orINSERT INTO table_name (column_name1, column_name2,…) VALUES (value1, value2,….) LIKE SELECT column_name(s) FROM table_name WHERE column_name LIKE pattern ORDER BY SELECT column_name(s) FROM table_name ORDER BY column_name [ASC\DESC] SELECT SELECT column_name(s) FROM table_name SELECT * SELECT * FROM table_name SELECT DISTINCT SELECT DISTINCT column_name(s) FROM table_name SELECT INTO (used to create backup copies of tables) SELECT INTO new_table_name FROM original_table_nameor*SELECT column_name(s) INTO new_table_name FROM original_table_name TRUNCATE TABLE (deletes only the data inside the table) TRUNCATE TABLE table_name UPDATE UPDATE table_name SET column_name=new_value [, column_name=new_value] WHERE column_name=some_value WHERE SELECT column_name(s) FROM table_name WHERE condition 一个CASE的例子12345678910111213select Max(id) from apply_data as d;UPDATE apply_dataSET pingshen = case id%8 WHEN 0 THEN "253" WHEN 1 THEN "254" WHEN 2 THEN "255" WHEN 3 THEN "256" WHEN 4 THEN "257" WHEN 5 THEN "258" WHEN 6 THEN "259" WHEN 7 THEN "260" ENDWHERE id BETWEEN 1 and d]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用]]></title>
    <url>%2F2019%2F05%2F07%2FGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git使用Github建立私有项目并将本地项目文件上传首先在GitHub上建立私有项目 然后跳转到本地对应项目目录，输入： 1git init 生成git管理 之后输入： 1git add . 将文件夹中所有文件添加到仓库 之后输入： 1git commit -m "first commit" 表示此次git的注释 再输入： 1git remote add origin https://XXX.git 将本地仓库关联到Github上 最后输入： 1git push -u origin master 上传至Github仓库，根据提示输入用户名和密码 使用Github提交代码123456#Github提交代码git status #查看当前状态git add . #或者 git add xxx 添加到本地Git缓冲区git commit -m "message" #推送修改到本地git库中git pull &lt;远程主机名&gt; &lt;远程分支名&gt; #origin mastergit push &lt;远程主机名&gt; &lt;远程分支名&gt; 采用SSH方式连接Github123456789101112131415#采用SSH方式连接Github（默认为https需要每次输入用户名密码）#首先查看git当前连接方式git remote -v#然后移除git remote rm origin#添加ssh方式/git remote add origin git@github.com:username/yourrepo.gitgit push origin#生成SSH公钥,并复制ssh-keygen -t rsa -C "youremail"vi /root/.ssh/id_rsa.pub#到Github设置里找到相应的SSH&amp;GPG key添加 ssh公钥#再次查看 连接方式git remote -v .gitignore格式规范文件 .gitignore 的格式规范如下： 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反 ​ 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 12345678910111213# 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO# 忽略 build/ 目录下的所有文件build/# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录下所有扩展名为 txt 的文件doc/**/*.txt Git常用命令12345678910111213141516171819202122232425git clone &lt;address&gt;：复制代码库到本地；git add &lt;file&gt; ...：添加文件到代码库中；git rm &lt;file&gt; ...：删除代码库的文件；git commit -m &lt;message&gt;：提交更改，在修改了文件以后，使用这个命令提交修改。git pull：从远程同步代码库到本地。git push：推送代码到远程代码库。git branch：查看当前分支。带*是当前分支。git branch &lt;branch-name&gt;：新建一个分支。git branch -d &lt;branch-name&gt;：删除一个分支。git checkout &lt;branch-name&gt;：切换到指定分支。git log：查看提交记录（即历史的 commit 记录）。git status：当前修改的状态，是否修改了还没提交，或者那些文件未使用。git reset &lt;log&gt;：恢复到历史版本。 参考链接： https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基本操作]]></title>
    <url>%2F2019%2F04%2F15%2Fmysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[mysql基本操作安装123456789#在CentOS7.1安装mysqlwget https://repo.mysql.com/mysql57-community-release-el7.rpmsudo yum localinstall mysql57-community-release-el7.rpmyum repolist all | grep mysqlsudo yum-config-manager --enable mysql57-communitysudo yum install mysql-community-serversudo service mysqld startsudo chkconfig mysqld onmysql_secure_installation 基本使用123456789101112131415#mysql安装后的默认密码获取grep "temporary password" /var/log/mysqld.log#登陆之后在修改kRMx,HhtE5N!#启动mysqlservice mysqld startmysql -u root -pSET PASSWORD = PASSWORD('lns');#创建数据库，并导入文件create database lns;use lns;set names utf8;source /root/lns.sql; mysql导出数据库mysqldump -u用戶名 -p密码 -d 数据库名 表名 &gt; 脚本名; 1234567891011导出整个数据库结构和数据mysqldump -h localhost -uroot -p123456 database &gt; dump.sql导出单个数据表结构和数据mysqldump -h localhost -uroot -p123456 database table &gt; dump.sql导出整个数据库结构（不包含数据）mysqldump -h localhost -uroot -p123456 -d database &gt; dump.sql导出单个数据表结构（不包含数据）mysqldump -h localhost -uroot -p123456 -d database table &gt; dump.sql]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在PHP环境下安装Composer]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%9C%A8PHP%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Composer%2F</url>
    <content type="text"><![CDATA[在PHP环境下安装Composer 由于项目需要安装PHPOffice所以要先安装Composer 但是去官网试试下载了他的installer发现总是卡在最后一步 没办法只好再次百度，发现分为三步， 第一步. 修改php.exe同目录的php.ini，在里面搜索 ;extension=php_openssl.dll ，把前面的分号去掉。(这一步已经完成了) 第二步. 用如下三条命令安装Composer 123php -r "copy('https://install.phpcomposer.com/installer', 'composer-setup.php');"php composer-setup.phpphp -r "unlink('composer-setup.php');" 执行第一条命令下载下来的 composer-setup.php 脚本将简单地检测 php.ini 中的参数设置，如果某些参数未正确设置则会给出警告；然后下载最新版本的 composer.phar 文件到当前目录。 上述 3 条命令的作用依次是： 下载安装脚本 － composer-setup.php － 到当前目录。 执行安装过程。 删除安装脚本。 最后会下载一个composer.phar文件。 局部安装上述下载 Composer 的过程正确执行完毕后，可以将 composer.phar 文件复制到任意目录（比如项目根目录下），然后通过 php composer.phar 指令即可使用 Composer 了！ 全局安装全局安装是将 Composer 安装到系统环境变量 PATH 所包含的路径下面，然后就能够在命令行窗口中直接执行 composer 命令了。 Mac 或 Linux 系统：打开命令行窗口并执行如下命令将前面下载的 composer.phar 文件移动到 /usr/local/bin/ 目录下面： 复制 1sudo mv composer.phar /usr/local/bin/composer Windows 系统： 找到并进入 PHP 的安装目录（和你在命令行中执行的 php 指令应该是同一套 PHP）。 将 composer.phar 复制到 PHP 的安装目录下面，也就是和 php.exe在同一级目录。 在 PHP 安装目录下新建一个 composer.bat 文件，并将下列代码保存到此文件中。 复制 1@php "%~dp0composer.phar" %* 最后重新打开一个命令行窗口试一试执行 composer --version 看看是否正确输出版本号。 然而这是骗自己的。。。放到其他目录就不行了，不知道是不是没加进环境变量的原因，但是重跑一遍installer之后又能安装了，那就这样吧。 参考链接：https://pkg.phpcomposer.com/#how-to-install-composer https://docs.phpcomposer.com/00-intro.html 切换国内源： composer config -g repo.packagist composer https://packagist.phpcomposer.com 安装PHPWord composer require “phpoffice/phpword” composer install https://phpword.readthedocs.io/en/latest/installing.html#installation GitHub项目在这：https://github.com/PHPOffice/PHPWord 官方文档在这：http://phpword.readthedocs.io/en/latest/index.html 但是还是没法复制 问题待解决]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wamp64在不同的端口下部署多项目]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%9C%A8Windows%E7%9A%84Wamp64%E4%B8%8B%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%B8%8B%E9%83%A8%E7%BD%B2%E5%A4%9A%E9%A1%B9%E7%9B%AE%EF%BC%9A%2F</url>
    <content type="text"><![CDATA[在Windows的Wamp64下在不同的端口下部署多项目：首先打开注释： 12# Virtual hostsInclude conf/extra/httpd-vhosts.conf 修改C:\wamp64\bin\apache\apache2.4.37\conf\extra下的 httpd-vhosts.conf 12345678910111213141516171819202122232425262728293031323334# Virtual Hosts#&lt;VirtualHost *:80&gt; ServerName localhost ServerAlias localhost DocumentRoot &quot;$&#123;INSTALL_DIR&#125;/www&quot; &lt;Directory &quot;$&#123;INSTALL_DIR&#125;/www/&quot;&gt; Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require local &lt;/Directory&gt;&lt;/VirtualHost&gt;Listen 88&lt;VirtualHost *:88&gt; ServerName localhost DocumentRoot C:/wamp64/www/jsjxh/src &lt;Directory &quot;C:/wamp64/www/jsjxh/src&quot;&gt; Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require local &lt;/Directory&gt;&lt;/VirtualHost&gt;Listen 777&lt;VirtualHost *:777&gt; ServerName localhost DocumentRoot C:/wamp64/www/2017 &lt;Directory &quot;C:/wamp64/www/2017&quot;&gt; Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require local &lt;/Directory&gt;&lt;/VirtualHost&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客优化]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[博客优化hexo主题：https://www.zhihu.com/question/24422335 NexT主题下载：https://github.com/iissnan/hexo-theme-next/releases hexo官方文档：https://hexo.io/zh-cn/docs/tag-plugins NexT官方文档：http://theme-next.iissnan.com/getting-started.html MarkDown编辑器：Typora 主要思想就是有两个 _config.yml 一个是项目相关的，另外一个是主题的配置 要调整的要分清结构 调整字体大小： F:\blog\themes\next\source\css_variables下的base.styl 12345678910// Font size$font-size-base = 16px //修改以前是14，我改成了16$font-size-small = $font-size-base - 2px$font-size-smaller = $font-size-base - 4px$font-size-large = $font-size-base + 2px$font-size-larger = $font-size-base + 4px// Headings font size$font-size-headings-step = 2px$font-size-headings-base = 24px //这个是标题大小，如果你觉得不满意，可以改的更大一点 后续等待添加。。。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建流程]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[引言​ 今天心血来潮总算把自己的博客给搭建好了，其实这个想法早就有了，但是看着要不是用WordPress，还是Django之类的框架都比较麻烦，而且需要购买域名所以就一直没有认真去做。很多东西也只是用MarkDown写完放在本地，一直没有PO上网。 Jekyll + Github​ 这次主要是因为看见有一篇微博写了怎么利用Github写个人主页。 原文：https://towardsdatascience.com/how-to-create-a-free-github-pages-website-53743d7524e1 大略看了下，好像还涉及前端的知识，由于不是主攻方向，正准备放弃的时候，发现关键词 Jekyll ！于是把Jekyll + Github 百度一下： 官网：https://www.jekyll.com.cn/ 参考：https://blog.csdn.net/Hanghang_/article/details/78944672 发现流程主要是： 注册Github（这个基本可以略过） 选择主题 主题商店：http://jekyllthemes.org/ Fork 别人的项目，把名字修改成:{username}.github.io 用Git把项目下载到本地然后开始修改 开始写博客 非常凑巧的是他的博客也是用md格式转化而成的，本来这应该是个非常顺利的过程。但是问题出现在第二步，不知道为什么我选的那个主题的作者好像没公开他的源码，这就非常纠结了。其他的主题也不能说不行，就是不太合胃口，于是开始重新搜索，结果发现另外一种方式，Hexo + Github + NexT主题。 Hexo + Github + NexT主题一. 前期准备 注册Github，添加项目，项目名字格式{username}.github.io 安装Git和Node.js（地址就不放了） 安装Hexo，建立新文件夹放博客的文件，在该目录下右键点击Git Bash Here，打开git的控制台窗口。操作都在git控制台进行，（当然也可以用Windows自带的控制台） 定位到该目录下，输入npm install hexo-cli -g安装Hexo。会有几个报错，无视它就行。 然后输入npm install hexo --save继续安装。 安装完后输入hexo -v验证是否安装成功。 输入hexo init初始化文件夹，接着输入npm install安装必备的组件。 这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开[http://localhost:4000/] 默认是4000 也可以用-p 来指定端口。 演示效果如上图（自己的忘存了。。。），我自己在这里碰见N次502 错误，最后才发现是SSR没关导致的，最后改成直连就能显示了。 最后按ctrl+c关闭本地服务器。 二. 配置Git ssh1. 设置Git的user name和email12git config --global user.name "&#123;username&#125;"git config --global user.email "&#123;emailaddr&#125;" 2. 检查是否已经有SSH Key12cd ~/.sshls 列出文件看看是否有 id_isa 和 id_isa.pub 文件 如果有可以跳过生成密钥这一阶段 生成密钥 1ssh-keygen -t rsa -C "&#123;email&#125;" ​ 如果不需要密码的话，连续3个回车。最后得到了两个文件：id_rsa和id_rsa.pub。 默认的存储路径是： 1C:\Users\&#123;UserName&#125;\.ssh 4. 添加密钥到ssh-agent​ 确保 ssh-agent 是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器， ​ 运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。 12# start the ssh-agent in the backgroundeval "$(ssh-agent -s)" ​ 添加生成的 SSH key 到 ssh-agent。 1ssh-add ~/.ssh/id_rsa 5. 登陆Github, 添加 ssh​ 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。 ​ 打开C:\Users\{UserName}\.ssh\id_rsa.pub，注意是隐藏文件夹，将其中的内容复制到新建的SSH中。 ​ 输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。 ​ 打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。 ​ 修改最后一行的配置： 1234deploy: type: git repository: https://github.com/&#123;username&#125;/&#123;username&#125;.github.io branch: master repository修改为你自己的github项目地址。 三.文章相关操作写文章、发布文章​ 首先在博客根目录下右键打开git，安装一个扩展npm install hexo-deployer-git --save。 ​ 然后输入hexo new post &quot;article title&quot;，新建一篇文章。 ​ 然后打开博客目录下的\source\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。 ​ 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章。 ​ 当然这一步也可以用之前写好的md文件放进去加一个Yaml格式的头在最前面里面写上标题，创建时间，等相关信息也是可以自动生成的。 ​ 至于其他的比如换主题之类的就留到下一篇吧。这个基本上把博客给搭建完了。 参考1：https://blog.csdn.net/gdutxiaoxu/article/details/53573399 参考2：https://zhuanlan.zhihu.com/p/35668237 hexo中文官网：https://hexo.io/zh-cn/docs/]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基本知识（3）]]></title>
    <url>%2F2019%2F04%2F03%2FJava-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java 基本知识（3）十二、封装的作用和意义需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。说的专业一点，封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 123我们程序设计要追求“高内聚，低耦合”。 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。 编程中封装的具体优点 提高代码的安全性。 提高代码的复用性。 “高内聚”：封装细节，便于修改内部代码，提高可维护性。 “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。 封装的实现—使用访问控制符 Java是使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露的。 Java中4种“访问控制符”分别为private、default、protected、public，它们说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性。 表 访问权限修饰符 private 表示私有，只有自己类能访问 default表示没有修饰符修饰，只有同一个包的类能访问 protected表示可以被同一个包的类以及其他包中的子类访问 public表示可以被该项目的所有包中的所有类访问 下面做进一步说明Java中4种访问权限修饰符的区别：首先我们创建4个类：Person类、Student类、Animal类和Computer类，分别比较本类、本包、子类、其他包的区别。 类的属性的处理 一般使用private访问权限。 提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 十三、多态多态的要点 多态是方法的多态，不是属性的多态(多态与属性无关)。 多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了 十四、变量的转型 父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。 向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型! 十五、final关键字的作用修饰变量被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。 1final int MAX_SPEED = 120; 修饰方法该方法不可被子类重写。但是可以被重载! 123final void study()&#123; &#125; 修饰类修饰的类不能被继承。比如：Math、String等。 123final class A &#123; &#125; 十六、抽象方法抽象类抽象方法使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。 抽象类包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 【示例】抽象类和抽象方法的基本用法 123456789101112131415161718192021//抽象类abstract class Animal &#123; abstract public void shout(); //抽象方法&#125;class Dog extends Animal &#123; //子类必须实现父类的抽象方法，否则编译错误 public void shout() &#123; System.out.println("汪汪汪！"); &#125; public void seeDoor()&#123; System.out.println("看门中...."); &#125;&#125;//测试抽象类public class TestAbstractClass &#123; public static void main(String[] args) &#123; Dog a = new Dog(); a.shout(); a.seeDoor(); &#125;&#125; 抽象类的使用要点 有抽象方法的类只能定义成抽象类 抽象类不能实例化，即不能用new来实例化抽象类。 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 抽象类只能用来被继承。 抽象方法必须被子类实现。 十七、接口的定义和使用声明格式1234[访问修饰符] interface 接口名 [extends 父接口1，父接口2…] &#123; 常量定义； 方法定义；&#125; 定义接口的详细说明 访问修饰符：只能是public或默认。 接口名：和类名采用相同命名机制。 extends：接口可以多继承。 常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。 方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。 要点 子类通过implements来实现接口中的规范。 接口不能创建实例，但是可用于声明引用变量类型。 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。 JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。 JDK1.8后，接口中包含普通的静态方法。 接口的使用1234567891011121314151617181920212223242526272829303132333435363738public class TestInterface &#123; public static void main(String[] args) &#123; Volant volant = new Angel(); volant.fly(); System.out.println(Volant.FLY_HIGHT); Honest honest = new GoodMan(); honest.helpOther(); &#125;&#125;/**飞行接口*/interface Volant &#123; int FLY_HIGHT = 100; // 总是：public static final类型的； void fly(); //总是：public abstract void fly();&#125;/**善良接口*/interface Honest &#123; void helpOther();&#125;/**Angle类实现飞行接口和善良接口*/class Angel implements Volant, Honest&#123; public void fly() &#123; System.out.println("我是天使，飞起来啦！"); &#125; public void helpOther() &#123; System.out.println("扶老奶奶过马路！"); &#125;&#125;class GoodMan implements Honest &#123; public void helpOther() &#123; System.out.println("扶老奶奶过马路！"); &#125; &#125;class BirdMan implements Volant &#123; public void fly() &#123; System.out.println("我是鸟人，正在飞！"); &#125;&#125; 接口支持多继承，和类的继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切。 接口的多继承123456789101112131415161718interface A &#123; void testa();&#125;interface B &#123; void testb();&#125;/**接口可以多继承：接口C继承接口A和B*/interface C extends A, B &#123; void testc();&#125;public class Test implements C &#123; public void testc() &#123; &#125; public void testa() &#123; &#125; public void testb() &#123; &#125;&#125; 十八、内部类内部类的概念 一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(inner classes)。 内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰。 注意内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同。 内部类介绍123456789101112131415/**外部类Outer*/class Outer &#123; private int age = 10; public void show()&#123; System.out.println(age);//10 &#125; /**内部类Inner*/ public class Inner &#123; //内部类中可以声明与外部类同名的属性与方法 private int age = 20; public void show()&#123; System.out.println(age);//20 &#125; &#125;&#125; 内部类的作用 内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。 内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。 接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。 内部类的使用场合 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。 使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。 内部类的分类 在Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。 成员内部类(可以使用private、default、protected、public任意进行修饰。 类文件：外部类$内部类.class) a) 非静态内部类外部类里使用非静态内部类和平时使用其他类没什么不同 i. 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。 ii. 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。 iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。 iv. 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。 v. 成员变量访问要点： 内部类里方法的局部变量：变量名。 内部类属性：this.变量名。 外部类属性：外部类名.this.变量名。 【举例】123456789101112class Outer &#123; private int age = 10; class Inner &#123; int age = 20; public void show() &#123; int age = 30; System.out.println("内部类方法里的局部变量age:" + age);// 30 System.out.println("内部类的成员变量age:" + this.age);// 20 System.out.println("外部类的成员变量age:" + Outer.this.age);// 10 &#125; &#125;&#125; vi. 内部类的访问： 外部类中定义内部类： 1new Inner() 外部类以外的地方使用非静态内部类： 1Outer.Inner varname = new Outer().new Inner()。 内部类的访问 12345678910public class TestInnerClass &#123; public static void main(String[] args) &#123; //先创建外部类实例，然后使用该外部类实例创建内部类实例 Outer.Inner inner = new Outer().new Inner(); inner.show(); Outer outer = new Outer(); Outer.Inner inn = outer.new Inner(); inn.show(); &#125;&#125; b) 静态内部类i. 定义方式：123static class ClassName &#123;//类体&#125; ii. 使用要点：1231. 当一个静态内部类对象存在，并不一定存在对应的外部类对象。 因此，静态内部类的实例方法不能直接访问外部类的实例方法。2. 静态内部类看做外部类的一个静态成员。 因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过 new 静态内部类()访问静态内部类的实例。 静态内部类的访问123456789101112class Outer&#123; //相当于外部类的一个静态成员 static class Inner&#123; &#125;&#125;public class TestStaticInnerClass &#123; public static void main(String[] args) &#123; //通过 new 外部类名.内部类名() 来创建内部类对象 Outer.Inner inner =new Outer.Inner(); //Outer.Inner inner = new Outer().new Inner(); 非静态内部类 &#125;&#125; 匿名内部类1适合那种只需要使用一次的类。比如：键盘监听操作等等。 语法123new 父类构造器(实参类表) \实现接口 () &#123; //匿名内部类类体！&#125; 匿名内部类的使用123456789101112131415161718this.addWindowListener(new WindowAdapter()&#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;);this.addKeyListener(new KeyAdapter()&#123; @Override public void keyPressed(KeyEvent e) &#123; myTank.keyPressed(e); &#125; @Override public void keyReleased(KeyEvent e) &#123; myTank.keyReleased(e); &#125; &#125;); 注意 匿名内部类没有访问修饰符。 匿名内部类没有构造方法。因为它连名字都没有那又何来构造方法呢。 局部内部类还有一种内部类，它是定义在方法内部的，作用域只限于本方法，称为局部内部类。 局部内部类的的使用主要是用来解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类。局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法中被使用，出了该方法就会失效。 局部内部类在实际开发中应用很少。 方法中的内部类1234567891011121314public class Test2 &#123; public void show() &#123; //作用域仅限于该方法 class Inner &#123; public void fun() &#123; System.out.println("helloworld"); &#125; &#125; new Inner().fun(); &#125; public static void main(String[] args) &#123; new Test2().show(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基本知识（2）]]></title>
    <url>%2F2019%2F04%2F03%2FJava-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java 基本知识（2）七、this关键字对象创建的过程和this的本质 构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步： 分配对象空间，并将对象成员变量初始化为0或空 执行属性值的显示初始化 执行构造方法 返回对象的地址给相关的变量 this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。 this最常的用法 在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。 this不能用于static方法中。 this代表“当前对象”示例1234567891011121314151617181920`public class User &#123; int id; //id String name; //账户名 String pwd; //密码 public User() &#123; &#125; public User(int id, String name) &#123; System.out.println("正在初始化已经创建好的对象："+this); this.id = id; //不写this，无法区分局部变量id和成员变量id this.name = name; &#125; public void login()&#123; System.out.println(this.name+",要登录！"); //不写this效果一样 &#125; public static void main(String[] args) &#123; User u3 = new User(101,"高小七"); System.out.println("打印高小七对象："+u3); u3.login(); &#125; &#125; 运行结果如图所示。 this()调用重载构造方法1234567891011121314151617181920212223242526272829public class TestThis &#123; int a, b, c; TestThis() &#123; System.out.println("正要初始化一个Hello对象"); &#125; TestThis(int a, int b) &#123; // TestThis(); //这样是无法调用构造方法的！ this(); // 调用无参的构造方法，并且必须位于第一行！ a = a;// 这里都是指的局部变量而不是成员变量 // 这样就区分了成员变量和局部变量. 这种情况占了this使用情况大多数 this.a = a; this.b = b; &#125; TestThis(int a, int b, int c) &#123; this(a, b); // 调用带参的构造方法，并且必须位于第一行！ this.c = c; &#125; void sing() &#123; &#125; void eat() &#123; this.sing(); // 调用本类中的sing(); System.out.println("你妈妈喊你回家吃饭！"); &#125; public static void main(String[] args) &#123; TestThis hi = new TestThis(2, 3); hi.eat(); &#125;&#125; 八、static关键字特点在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点： 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!! 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。) 在static方法中不可直接访问非static的成员。 核心要点： static修饰的成员变量和方法，从属于类。 普通变量和方法从属于对象的。 12345678910111213141516171819202122232425262728293031public class User2 &#123; int id; // id String name; // 账户名 String pwd; // 密码 static String company = "北京尚学堂"; // 公司名称 public User2(int id, String name) &#123; this.id = id; this.name = name; &#125; public void login() &#123; printCompany(); System.out.println(company); System.out.println("登录：" + name); &#125; public static void printCompany() &#123;// login();//调用非静态成员，编译就会报错 System.out.println(company); &#125; public static void main(String[] args) &#123; User2 u = new User2(101, "高小七"); User2.printCompany(); User2.company = "北京阿里爷爷"; User2.printCompany(); &#125;&#125; 静态初始化块构造方法用于对象的初始化!静态初始化块，用于类的初始化操作!在静态初始化块中不能直接访问非static成员。 注意事项： 静态初始化块执行顺序： 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。 构造方法执行顺序和上面顺序一样!! static初始化块 1234567891011121314151617public class User3 &#123; int id; //id String name; //账户名 String pwd; //密码 static String company; //公司名称 static &#123; System.out.println("执行类的初始化工作"); company = "北京尚学堂"; printCompany(); &#125; public static void printCompany()&#123; System.out.println(company); &#125; public static void main(String[] args) &#123; User3 u3 = new User3(); &#125;&#125; 九、参数传值机制 Java中，方法中所有参数都是“值传递”，也就是“传递的是值的副本”。 也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件改变不会影响原件。 基本数据类型参数的传值 传递的是值的副本。 副本改变不会影响原件。 引用类型参数的传值 传递的是值的副本。但是引用类型指的是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”。 多个变量指向同一个对象1234567891011121314151617181920212223242526public class User4 &#123; int id; //id String name; //账户名 String pwd; //密码 public User4(int id, String name) &#123; this.id = id; this.name = name; &#125; public void testParameterTransfer01(User4 u)&#123; u.name="高小八"; &#125; public void testParameterTransfer02(User4 u)&#123; u = new User4(200,"高三"); &#125; public static void main(String[] args) &#123; User4 u1 = new User4(100, "高小七"); u1.testParameterTransfer01(u1); System.out.println(u1.name); u1.testParameterTransfer02(u1); System.out.println(u1.name); 十、包包机制是Java中管理类的重要手段。 开发中，我们会遇到大量同名的类，通过包我们很容易对解决类重名的问题，也可以实现对类的有效管理。 包对于类，相当于文件夹对于文件的作用。 包的使用我们通过package实现对类的管理，package的使用有两个要点： 通常是类的第一句非注释性语句。 包名：域名倒着写即可，再加上模块名，便于内部管理类。 【示例】 package的命名举例 12345com.sun.test;com.oracle.test;cn.sxt.yuan.test;cn.sxt.yuan.view;cn.sxt.yuan.view.model; 注意事项： 写项目时都要加包，不要使用默认包。 com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分。 【示例】package的使用 123456package cn.yuan;public class Test &#123; public static void main(String[] args) &#123; System.out.println("helloworld"); &#125;&#125; Java中常用包 Java中的常用包 说明 java.lang 包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。 java.awt 包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 java.net 包含执行与网络相关的操作的类。 java.io 包含能提供多种输入/输出功能的类。 java.util 包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。 如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性。 注意要点： Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。 如果导入两个同名的类，只能用包名+类名来显示调用相关类： 1java.util.Date date = new java.util.Date(); 【示例】1234567891011121314import java.sql.Date;import java.util.*;//导入该包下所有的类。会降低编译速度，但不会降低运行速度。 public class Test&#123; public static void main(String[] args) &#123; //这里指的是java.sql.Date Date now; //java.util.Date因为和java.sql.Date类同名，需要完整路径 java.util.Date now2 = new java.util.Date(); System.out.println(now2); //java.util包的非同名类不需要完整路径 Scanner input = new Scanner(System.in); &#125;&#125; 十一、继承继承的实现1234567891011121314151617181920212223242526public class Test&#123; public static void main(String[] args) &#123; Student s = new Student("高淇",172,"Java"); s.rest(); s.study(); &#125;&#125;class Person &#123; String name; int height; public void rest()&#123; System.out.println("休息一会！"); &#125; &#125;class Student extends Person &#123; String major; //专业 public void study()&#123; System.out.println("在尚学堂，学习Java"); &#125; public Student(String name,int height,String major) &#123; //天然拥有父类的属性 this.name = name; this.height = height; this.major = major; &#125;&#125; 继承的使用要点1.父类也称作超类、基类等。 2.Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。 3.Java中类没有多继承，接口有多继承。 4.子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。 5.如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。 方法的重写override方法重写的三个要点123451.“==”： 方法名、形参列表相同。2.“≤”：返回值类型和声明异常类型，子类小于等于父类。3.“≥”： 访问权限，子类大于等于父类。 【示例】方法重写1234567891011121314151617181920212223242526272829303132333435public class TestOverride &#123; public static void main(String[] args) &#123; Vehicle v1 = new Vehicle(); Vehicle v2 = new Horse(); Vehicle v3 = new Plane(); v1.run(); v2.run(); v3.run(); v2.stop(); v3.stop(); &#125;&#125; class Vehicle &#123; // 交通工具类 public void run() &#123; System.out.println("跑...."); &#125; public void stop() &#123; System.out.println("停止不动"); &#125;&#125;class Horse extends Vehicle &#123; // 马也是交通工具 public void run() &#123; // 重写父类方法 System.out.println("四蹄翻飞，嘚嘚嘚..."); &#125;&#125; class Plane extends Vehicle &#123; public void run() &#123; // 重写父类方法 System.out.println("天上飞！"); &#125; public void stop() &#123; System.out.println("空中不能停，坠毁了！"); &#125;&#125; super关键字 super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。 123使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。若是构造方法的第一行代码没有显式的调用super(...)或者this(...);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。 super关键字的使用12345678910111213141516171819202122public class TestSuper01 &#123; public static void main(String[] args) &#123; new ChildClass().f(); &#125;&#125;class FatherClass &#123; public int value; public void f()&#123; value = 100; System.out.println ("FatherClass.value="+value); &#125;&#125;class ChildClass extends FatherClass &#123; public int value; public void f() &#123; super.f(); //调用父类对象的普通方法 value = 200; System.out.println("ChildClass.value="+value); System.out.println(value); System.out.println(super.value); //调用父类对象的成员变量 &#125;&#125; 继承树追溯属性/方法查找顺序：(比如：查找变量h)12345671. 查找当前类中有没有属性h2. 依次上溯每个父类，查看每个父类中是否有h，直到Object3. 如果没找到，则出现编译错误。4. 上面步骤，只要找到h变量，则这个过程终止。 构造方法调用顺序构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。 注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复。 构造方法向上追溯执行测试12345678910111213141516public class TestSuper02 &#123; public static void main(String[] args) &#123; System.out.println("开始创建一个ChildClass对象......"); new ChildClass(); &#125;&#125;class FatherClass &#123; public FatherClass() &#123; System.out.println("创建FatherClass"); &#125;&#125;class ChildClass extends FatherClass &#123; public ChildClass() &#123; System.out.println("创建ChildClass"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基本知识（1）]]></title>
    <url>%2F2019%2F04%2F03%2FJava-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java 基本知识（1）一、数据类型Java支持的类型分为两类：基本类型和引用类型 1.基本类型4类8种： （1）整型:int、short、long、byte。 （2）浮点型:float、double。 （3）字符型：char。 （4）布尔型：boolean。 2.引用类型引用类型包括类、接口、枚举和数组类型、null类型。 空引用null只能被被转化为引用类型，不能转化成基本类型，因此，不能把一个null值赋给基本类型的变量。 备注：（1）字符串类型是一个类，即引用类型 二、循环用法if的用法123456789if(statement)&#123; &#125;else if()&#123; &#125;else &#123; &#125; switch的用法12345678910switch (表达式) &#123; case 值1: 语句序列1; [break]; case 值2: 语句序列2; [break]; … … … … … [default:默认语句;] &#125; while和for的用法12345678while(statement)&#123; &#125;for (初始表达式; 布尔表达式; 迭代因子) &#123; 循环体; &#125; 三、重载构成方法重载的条件： 1.不同的含义：形参类型、形参个数、形参顺序不同 2.只有返回值不同不构成方法的重载 3.只有形参的名称不同，不构成方法的重载 四、面向对象和面向过程的总结 1、都是解决问题的思维方式，都是代码组织的方式。 2、解决简单问题可以使用面向过程 3、解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。 面向对象思考方式 遇到复杂问题，先从问题中找名词，然后确立这些名词哪些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。 建议 1.面向对象具有三大特征：封装性、继承性和多态性，而面向过程没有继承性和多态性，并且面向过程的封装只是封装功能，而面向对象可以封装数据和功能。所以面向对象优势更明显。 2.一个经典的比喻：面向对象是盖浇饭、面向过程是蛋炒饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。 五、栈与堆栈的特点 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 栈属于线程私有，不能实现线程间的共享! 栈的存储特性是“先进后出，后进先出” 栈是由系统自动分配，速度快!栈是一个连续的内存空间! 堆的特点 堆用于存储创建好的对象和数组(数组也是对象) JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢! 方法区(又叫静态区)特点 JVM只有一个方法区，被所有线程共享! 方法区实际也是堆，只是用于存储类、常量相关的信息! 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等) 通过new关键字调用!! 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加! 构造器的方法名必须和类名一致! 六、内存管理与GC内存管理 Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。 对象空间的分配：使用new关键字创建对象即可 对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。 垃圾回收过程任何一种垃圾回收算法一般要做两件基本事情： 发现无用的对象 回收无用对象占用的内存空间。 垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的就是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。 垃圾回收相关算法引用计数法 堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。 【示例4-7】循环引用示例 123456789101112public class Student &#123; String name; Student friend; public static void main(String[] args) &#123; Student s1 = new Student(); Student s2 = new Student(); s1.friend = s2; s2.friend = s1; s1 = null; s2 = null; &#125;&#125; s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。 引用可达法(根搜索算法) 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 分代垃圾回收机制分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。 年轻代 所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。 年老代 在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。 持久代 用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。 垃圾回收方案Minor GC: 用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空) Major GC： 用于清理老年代区域。 Full GC： 用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。 垃圾回收过程1、新创建的对象，绝大多数都会存储在Eden中， 2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区 3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。 4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中， 5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC） 在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC： 1.年老代(Tenured)被写满 2.持久代(Perm)被写满 3.System.gc()被显式调用（程序建议GC启动，不是调用GC） 4.上一次GC之后Heap的各域分配策略动态变化]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
