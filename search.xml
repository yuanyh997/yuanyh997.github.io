<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[go-redis 学习指南]]></title>
    <url>%2F2019%2F05%2F18%2FGolang%20redis%20%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[go-redis 学习指南安装我使用的是 https://github.com/go-redis/r… 这个 golang 客户端, 因此安装方式如下: go get gopkg.in/redis.v4 接着在代码中导入此包即可: import “gopkg.in/redis.v4” 基本操作创建客户端通过 redis.NewClient 函数即可创建一个 redis 客户端, 这个方法接收一个 redis.Options 对象参数, 通过这个参数, 我们可以配置 redis 相关的属性, 例如 redis 服务器地址, 数据库名, 数据库密码等. 下面是一个连接的例子: 1234567891011121314// 创建 redis 客户端func createClient() *redis.Client &#123; client := redis.NewClient(&amp;redis.Options&#123; Addr: "localhost:6379", Password: "", DB: 0, &#125;) // 通过 cient.Ping() 来检查是否成功连接到了 redis 服务器 pong, err := client.Ping().Result() fmt.Println(pong, err) return client&#125; String 操作redis 的 String 操作有: 123456789101112131415161718192021222324252627set(key, value)：给数据库中名称为key的string赋予值valueget(key)：返回数据库中名称为key的string的valuegetset(key, value)：给名称为key的string赋予上一次的valuemget(key1, key2,…, key N)：返回库中多个string的valuesetnx(key, value)：添加string，名称为key，值为valuesetex(key, time, value)：向库中添加string，设定过期时间timemset(key N, value N)：批量设置多个string的值msetnx(key N, value N)：如果所有名称为key i的string都不存在incr(key)：名称为key的string增1操作incrby(key, integer)：名称为key的string增加integerdecr(key)：名称为key的string减1操作decrby(key, integer)：名称为key的string减少integerappend(key, value)：名称为key的string的值附加valuesubstr(key, start, end)：返回名称为key的string的value的子串 在 go-redis 中, 我们可以直接找到对应的操作方法, 直接上代码: 12345678910111213141516171819202122232425262728293031323334353637383940// String 操作func stringOperation(client *redis.Client) &#123; // 第三个参数是过期时间, 如果是0, 则表示没有过期时间. err := client.Set("name", "xys", 0).Err() if err != nil &#123; panic(err) &#125; val, err := client.Get("name").Result() if err != nil &#123; panic(err) &#125; fmt.Println("name", val) // 这里设置过期时间. err = client.Set("age", "20", 1 * time.Second).Err() if err != nil &#123; panic(err) &#125; client.Incr("age") // 自增 client.Incr("age") // 自增 client.Decr("age") // 自减 val, err = client.Get("age").Result() if err != nil &#123; panic(err) &#125; fmt.Println("age", val) // age 的值为21 // 因为 key "age" 的过期时间是一秒钟, 因此当一秒后, 此 key 会自动被删除了. time.Sleep(1 * time.Second) val, err = client.Get("age").Result() if err != nil &#123; // 因为 key "age" 已经过期了, 因此会有一个 redis: nil 的错误. fmt.Printf("error: %v\n", err) &#125; fmt.Println("age", val)&#125; list 操作redis 的 list 操作有: 12345678910111213141516171819202122232425rpush(key, value)：在名称为key的list尾添加一个值为value的元素lpush(key, value)：在名称为key的list头添加一个值为value的 元素llen(key)：返回名称为key的list的长度lrange(key, start, end)：返回名称为key的list中start至end之间的元素ltrim(key, start, end)：截取名称为key的listlindex(key, index)：返回名称为key的list中index位置的元素lset(key, index, value)：给名称为key的list中index位置的元素赋值lrem(key, count, value)：删除count个key的list中值为value的元素lpop(key)：返回并删除名称为key的list中的首元素rpop(key)：返回并删除名称为key的list中的尾元素blpop(key1, key2,… key N, timeout)：lpop命令的block版本。brpop(key1, key2,… key N, timeout)：rpop的block版本。rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部 同样地, 在 go-redis 中也可以找到对应的方法, 下面是一个简单的示例: 123456789101112131415161718192021222324252627// list 操作func listOperation(client *redis.Client) &#123; client.RPush("fruit", "apple") //在名称为 fruit 的list尾添加一个值为value的元素 client.LPush("fruit", "banana") //在名称为 fruit 的list头添加一个值为value的 元素 length, err := client.LLen("fruit").Result() //返回名称为 fruit 的list的长度 if err != nil &#123; panic(err) &#125; fmt.Println("length: ", length) // 长度为2 value, err := client.LPop("fruit").Result() //返回并删除名称为 fruit 的list中的首元素 if err != nil &#123; panic(err) &#125; fmt.Println("fruit: ", value) value, err = client.RPop("fruit").Result() // 返回并删除名称为 fruit 的list中的尾元素 if err != nil &#123; panic(err) &#125; fmt.Println("fruit: ", value)&#125; set 操作redis 的 set 操作: 123456789101112131415161718192021222324252627sadd(key, member)：向名称为key的set中添加元素membersrem(key, member) ：删除名称为key的set中的元素memberspop(key) ：随机返回并删除名称为key的set中一个元素smove(srckey, dstkey, member) ：移到集合元素scard(key) ：返回名称为key的set的基数sismember(key, member) ：member是否是名称为key的set的元素sinter(key1, key2,…key N) ：求交集sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合sunion(key1, (keys)) ：求并集sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合sdiff(key1, (keys)) ：求差集sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合smembers(key) ：返回名称为key的set的所有元素srandmember(key) ：随机返回名称为key的set的一个元素 接下来是 go-redis 的 set 操作: 1234567891011121314151617181920212223242526272829303132// set 操作func setOperation(client *redis.Client) &#123; client.SAdd("blacklist", "Obama") // 向 blacklist 中添加元素 client.SAdd("blacklist", "Hillary") // 再次添加 client.SAdd("blacklist", "the Elder") // 添加新元素 client.SAdd("whitelist", "the Elder") // 向 whitelist 添加元素 // 判断元素是否在集合中 isMember, err := client.SIsMember("blacklist", "Bush").Result() if err != nil &#123; panic(err) &#125; fmt.Println("Is Bush in blacklist: ", isMember) // 求交集, 即既在黑名单中, 又在白名单中的元素 names, err := client.SInter("blacklist", "whitelist").Result() if err != nil &#123; panic(err) &#125; // 获取到的元素是 "the Elder" fmt.Println("Inter result: ", names) // 获取指定集合的所有元素 all, err := client.SMembers("blacklist").Result() if err != nil &#123; panic(err) &#125; fmt.Println("All member: ", all)&#125; hash 操作redis 的 hash 操作: 123456789101112131415161718192021hset(key, field, value)：向名称为key的hash中添加元素fieldhget(key, field)：返回名称为key的hash中field对应的valuehmget(key, (fields))：返回名称为key的hash中field i对应的valuehmset(key, (fields))：向名称为key的hash中添加元素field hincrby(key, field, integer)：将名称为key的hash中field的value增加integerhexists(key, field)：名称为key的hash中是否存在键为field的域hdel(key, field)：删除名称为key的hash中键为field的域hlen(key)：返回名称为key的hash中元素个数hkeys(key)：返回名称为key的hash中所有键hvals(key)：返回名称为key的hash中所有键对应的valuehgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value go-redis 中的 hash 操作: 12345678910111213141516171819202122232425262728293031// hash 操作func hashOperation(client *redis.Client) &#123; client.HSet("user_xys", "name", "xys"); // 向名称为 user_xys 的 hash 中添加元素 name client.HSet("user_xys", "age", "18"); // 向名称为 user_xys 的 hash 中添加元素 age // 批量地向名称为 user_test 的 hash 中添加元素 name 和 age client.HMSet("user_test", map[string]string&#123;"name": "test", "age":"20"&#125;) // 批量获取名为 user_test 的 hash 中的指定字段的值. fields, err := client.HMGet("user_test", "name", "age").Result() if err != nil &#123; panic(err) &#125; fmt.Println("fields in user_test: ", fields) // 获取名为 user_xys 的 hash 中的字段个数 length, err := client.HLen("user_xys").Result() if err != nil &#123; panic(err) &#125; fmt.Println("field count in user_xys: ", length) // 字段个数为2 // 删除名为 user_test 的 age 字段 client.HDel("user_test", "age") age, err := client.HGet("user_test", "age").Result() if err != nil &#123; fmt.Printf("Get user_test age error: %v\n", err) &#125; else &#123; fmt.Println("user_test age is: ", age) // 字段个数为2 &#125;&#125; 关于连接池redis.v4 包实现了 redis 的连接池管理, 因此我们就不需要自己手动管理 redis 的连接了. 默认情况下, redis.v4 的 redis 连接池大小是10, 不过我们可以在初始化 redis 客户端时自行设置连接池的大小, 例如: 123456client := redis.NewClient(&amp;redis.Options&#123; Addr: "localhost:6379", Password: "", DB: 0, PoolSize: 5,&#125;) 通过 redis.Options 的 PoolSize 属性, 我们设置了 redis 连接池的大小为5. 那么接下来我们来看一下这个设置有什么效果吧: 1234567891011121314151617181920// redis.v4 的连接池管理func connectPool(client *redis.Client) &#123; wg := sync.WaitGroup&#123;&#125; wg.Add(10) for i := 0; i &lt; 10; i++ &#123; go func() &#123; defer wg.Done() for j := 0; j &lt; 100; j++ &#123; client.Set(fmt.Sprintf("name%d", j), fmt.Sprintf("xys%d", j), 0).Err() client.Get(fmt.Sprintf("name%d", j)).Result() &#125; fmt.Printf("PoolStats, TotalConns: %d, FreeConns: %d\n", client.PoolStats().TotalConns, client.PoolStats().FreeConns); &#125;() &#125; wg.Wait()&#125; 上面的例子启动了10个 routine 来不断向 redis 读写数据, 然后我们通过 client.PoolStats() 获取连接池的信息. 运行这个例子, 输出如下: 12345678910111213141516171819PoolStats, TotalConns: 5, FreeConns: 1PoolStats, TotalConns: 5, FreeConns: 1PoolStats, TotalConns: 5, FreeConns: 1PoolStats, TotalConns: 5, FreeConns: 1PoolStats, TotalConns: 5, FreeConns: 1PoolStats, TotalConns: 5, FreeConns: 2PoolStats, TotalConns: 5, FreeConns: 2PoolStats, TotalConns: 5, FreeConns: 3PoolStats, TotalConns: 5, FreeConns: 4PoolStats, TotalConns: 5, FreeConns: 5 通过输出可以看到, 此时最大的连接池数量确实是 5 了, 并且一开始时, 因为 coroutine 的数量大于5, 会造成 redis 连接不足的情况(反映在 FreeConns 上就是前几次的输出 FreeConns 一直是1), 当某个 coroutine 结束后, 会释放此 redis 连接, 因此 FreeConns 会增加. 主函数123456789101112131415161718192021package mainimport ( "fmt" "gopkg.in/redis.v4" "time" "sync")func main() &#123; client := createClient() defer client.Close() stringOperation(client) listOperation(client) setOperation(client) hashOperation(client) connectPool(client)&#125;]]></content>
      <categories>
        <category>GO</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 操作 Redis]]></title>
    <url>%2F2019%2F05%2F18%2FGolang%20%E6%93%8D%E4%BD%9C%20Redis%2F</url>
    <content type="text"><![CDATA[Golang 操作 Redis安装第三方开源 Redis 库1) 使用第三方开源的 redis 库: github.com/garyburd/redigo/redis 2) 在使用 Redis 前，先安装第三方 Redis 库，在 GOPATH 路径下执行安装指令: ​ go get github.com/garyburd/redigo/redis Set/Get 接口1234567891011121314151617181920212223242526272829303132package main import ( "fmt" "github.com/garyburd/redigo/redis" //引入 redis 包)func main() &#123; //通过 go 向 redis 写入数据和读取数据 //1. 链接到 redis conn, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("redis.Dial err=", err) return&#125; defer conn.Close() //关闭.. //2. 通过 go 向 redis 写入数据 string [key-val] _, err = conn.Do("Set", "name", "tomjerry 猫猫") if err != nil &#123; fmt.Println("set err=", err) return &#125; //3. 通过 go 向 redis 读取数据 string [key-val] r, err := redis.String(conn.Do("Get", "name")) if err != nil &#123; fmt.Println("set err=", err) return &#125; //因为 conn.Do 返回 interface&#123;&#125; fmt.Println("操作 ok ", r)&#125; 操作 Hash说明: 通过 Golang 对 Redis 操作 Hash 数据类型 对 hash 数据结构，field-val 是一个一个放入和读取 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package main import ( "fmt" "github.com/garyburd/redigo/redis" //引入 redis 包)func main() &#123; //通过 go 向 redis 写入数据和读取数据 //1. 链接到 redis conn, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("redis.Dial err=", err) return &#125; defer conn.Close() //关闭.. //2. 通过 go 向 redis 写入数据 string [key-val] _, err = conn.Do("HSet", "user01", "name", "john") if err != nil &#123; fmt.Println("hset err=", err) return &#125; _, err = conn.Do("HSet", "user01", "age", 18) if err != nil &#123; fmt.Println("hset err=", err) return &#125; //3. 通过 go 向 redis 读取数据 r1, err := redis.String(conn.Do("HGet","user01", "name")) if err != nil &#123; fmt.Println("hget err=", err) return &#125; r2, err := redis.Int(conn.Do("HGet","user01", "age")) if err != nil &#123; fmt.Println("hget err=", err) return &#125; fmt.Printf("操作 ok r1=%v r2=%v \n", r1, r2)&#125; 批量写入hash 123456789101112131415161718192021222324252627282930313233package main import ( "fmt" "github.com/garyburd/redigo/redis" //引入 redis 包)func main() &#123; //通过 go 向 redis 写入数据和读取数据 //1. 链接到 redis conn, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("redis.Dial err=", err) return &#125; defer conn.Close() //关闭.. //2. 通过 go 向 redis 写入数据 string [key-val] _, err = conn.Do("HMSet", "user02", "name", "john", "age", 19) if err != nil &#123; fmt.Println("HMSet err=", err) return &#125; //3. 通过 go 向 redis 读取数据 r, err := redis.Strings(conn.Do("HMGet","user02", "name", "age")) if err != nil &#123; fmt.Println("hget err=", err) return &#125; for i, v := range r &#123; fmt.Printf("r[%d]=%s\n", i, v) &#125;&#125; 批量 Set/Get 数据说明: 通过 Golang 对 Redis 操作，一次操作可以 Set / Get 多个 key-val 数据 核心代码: 12345_, err = c.Do("MSet", "name", "尚硅谷", "address", "北京昌平~")r, err := redis.Strings(c.Do("MGet", "name", "address"))for _, v := range r &#123; fmt.Println(v)&#125; 给数据设置有效时间说明: 通过 Golang 对 Redis 操作，给 key-value 设置有效时间 核心代码: 12//给 name 数据设置有效时间为 10s_, err = c.Do("expire", "name", 10) 操作 List说明: 通过 Golang 对 Redis 操作 List 数据类型 核心代码: 12_, err = c.Do("lpush", "heroList", "no1:宋江", 30, "no2:卢俊义", 28) r, err := redis.String(c.Do("rpop", "heroList")) 总结基本流程： 1234567891011121314151617181920212223242526272829303132333435//1.首先导入相应的Redis包package main import ( "fmt" "github.com/garyburd/redigo/redis" //引入 redis 包)func main() &#123; //通过 go 向 redis 写入数据和读取数据 //2. 链接到 redis conn, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("redis.Dial err=", err) return &#125; defer conn.Close() //关闭.. //3. 通过 go 操作 redis 读取数据 // conn.Do("commandName",args) _, err = conn.Do("HMSet", "user02", "name", "john", "age", 19) if err != nil &#123; fmt.Println("HMSet err=", err) return &#125; //4. 通过 go 向 redis 读取数据 先读取，再转换成相应类型 //redis.Type(conn.Do("commandName",args) ) r, err := redis.Strings(conn.Do("HMGet","user02", "name", "age")) if err != nil &#123; fmt.Println("hget err=", err) return &#125; for i, v := range r &#123; fmt.Printf("r[%d]=%s\n", i, v) &#125;&#125;]]></content>
      <categories>
        <category>GO</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 基本使用]]></title>
    <url>%2F2019%2F05%2F16%2FRedis%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Redis 基本使用基本介绍Redis是一种NoSQL数据库 官网: http://redis.io/ 和 http://www.redis.cn/ Redis 在Windows下安装但是Redis不再支持Windows，所以去Github上下载微软支持版本 https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100 有两种版本 .msi是安装版本 .zip是已经编译版本 此次采用的第二种： 解压后的文件目录 其中redis-server.exe 是服务器端，需要一直开启。但是网上有另外一种安装服务的方法。 redis-cli.exe 是客户端命令行 redis.windows.conf 是配置文件 redis-benchmark：Redis性能测试工具，测试Redis在你的系统及你的配置下的读写性能。 安装Redis服务的方法1234#安装redis-server --service-install redis.windows.conf#启动redis-server --service-start Redis的基本使用命令参考：http://redisdoc.com 打开redis-cli.exe Redis的CRUDRedis的五大数据类型 String（字符串），Hash（哈希），List（列表），Set（集合），zset（sorted set：有序集合） String类型string是基本类型 key与value 一一对应 set[如果存在就相当于修改，不存在就是添加]/get/del setex(set with expire)键秒值 mset[同时设置一个或多个 key-value 对] ​ mget[同时获取多个 key-val] Hash (哈希，类似 golang 里的 Map)类型Redis hash 是一个键值对集合。var user1 map[string]string Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 hset/hget/hgetall/hdel 使用 hmset 和 hmget 可以一次性来设置多个 filed 的值和返回多个 field 的值 hlen 统计一个 hash 有几个元素. hexists key field， 查看哈希表 key 中，给定域 field 是否存在 List（列表）类型列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 List 本质是个链表, List 的元素 是有序的，元素的值可以重复 lpush/rpush/lrange/lpop/rpop/del Set（集合）类型Redis 的 Set 是 string 类型的无序集合 底层是 HashTable 数据结构, Set 也是存放很多字符串元素，字符串元素是无序的，而且元素的值不能重复 sadd/smembers[取出所有值]/sismember[判断值是否是成员] /srem [删除指定值]]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Quick Intro]]></title>
    <url>%2F2019%2F05%2F16%2FSQL%20Quick%20Intro%2F</url>
    <content type="text"><![CDATA[SQL Quick Intro基本用法12345678910111213//SQL基本用法select area form table_name where conditionupdate table_name set area = value where conditiondelete from table where conditionINSERT INTO 表名称 VALUES (值1, 值2,....)INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)drop table/database//清空数据TRUNCATE TABLE 表名称 SQL关键字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//关键字and/ or /notorder by desc asclike pattern //其中通配符 %为替代多个 _替代一个 [charlist] 其中任何一个 [！charlist] 不是其中任何一个in(val1,val2,...)between val1 and val2 //表的 SQL Alias 语法SELECT column_name(s)FROM table_nameAS alias_name列的 SQL Alias 语法SELECT column_name AS alias_nameFROM table_name//SQL UNION 语法 加上ALL允许重复值SELECT column_name(s) FROM table_name1UNION(ALL)SELECT column_name(s) FROM table_name2//SQL SELECT INTO 语法SELECT column_name(s)INTO new_table_name [IN externaldatabase] FROM old_tablename//SQL CREATE DATABASE 语法CREATE DATABASE database_name//SQL CREATE TABLE 语法CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,....)//SQL GROUP BY 语法SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name//SQL HAVING 语法SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_nameHAVING aggregate_function(column_name) operator value SQL Join()用法可以使用的 JOIN 类型，以及它们之间的差异。 JOIN（INNER JOIN）: 如果表中有至少一个匹配，则返回行LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行FULL JOIN: 只要其中一个表中存在匹配，就返回行 123456//JOIN 关键字语法SELECT column_name(s)FROM table_name1（XX）JOIN table_name2 ON table_name1.column_name=table_name2.column_name SQL数据类型 数据类型 描述 integer(size)int(size)smallint(size)tinyint(size) 仅容纳整数。在括号内规定数字的最大位数。 decimal(size,d)numeric(size,d) 容纳带有小数的数字。”size” 规定数字的最大位数。”d” 规定小数点右侧的最大位数。 char(size) 容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。在括号中规定字符串的长度。 varchar(size) 容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。在括号中规定字符串的最大长度。 date(yyyymmdd) 容纳日期。 SQL 约束约束用于限制加入表的数据的类型。 可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）。 我们将主要探讨以下几种约束： NOT NULL UNIQUE PRIMARY KEY FOREIGN KEY CHECK DEFAULT SQL函数 函数 描述 AVG(column) 返回某列的平均值 BINARY_CHECKSUM CHECKSUM CHECKSUM_AGG COUNT(column) 返回某列的行数（不包括NULL值） COUNT(*) 返回被选行数 COUNT(DISTINCT column) 返回相异结果的数目 FIRST(column) 返回在指定的域中第一个记录的值（SQLServer2000 不支持） LAST(column) 返回在指定的域中最后一个记录的值（SQLServer2000 不支持） MAX(column) 返回某列的最高值 MIN(column) 返回某列的最低值 STDEV(column) STDEVP(column) SUM(column) 返回某列的总和 VAR(column) VARP(column) SQL 语句速查 语句 语法 AND / OR SELECT column_name(s) FROM table_name WHERE condition AND\ OR condition ALTER TABLE (add column) ALTER TABLE table_name ADD column_name datatype ALTER TABLE (drop column) ALTER TABLE table_name DROP COLUMN column_name AS (alias for column) SELECT column_name AS column_alias FROM table_name AS (alias for table) SELECT column_name FROM table_name AS table_alias BETWEEN SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2 CREATE DATABASE CREATE DATABASE database_name CREATE INDEX CREATE INDEX index_name ON table_name (column_name) CREATE TABLE CREATE TABLE table_name ( column_name1 data_type, column_name2 data_type, ……. ) CREATE UNIQUE INDEX CREATE UNIQUE INDEX index_name ON table_name (column_name) CREATE VIEW CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition DELETE FROM DELETE FROM table_name (Note: Deletes the entire table!!)orDELETE FROM table_name WHERE condition DROP DATABASE DROP DATABASE database_name DROP INDEX DROP INDEX table_name.index_name DROP TABLE DROP TABLE table_name GROUP BY SELECT column_name1,SUM(column_name2) FROM table_name GROUP BY column_name1 HAVING SELECT column_name1,SUM(column_name2) FROM table_name GROUP BY column_name1 HAVING SUM(column_name2) condition value IN SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,..) INSERT INTO INSERT INTO table_name VALUES (value1, value2,….)orINSERT INTO table_name (column_name1, column_name2,…) VALUES (value1, value2,….) LIKE SELECT column_name(s) FROM table_name WHERE column_name LIKE pattern ORDER BY SELECT column_name(s) FROM table_name ORDER BY column_name [ASC\ DESC] SELECT SELECT column_name(s) FROM table_name SELECT * SELECT * FROM table_name SELECT DISTINCT SELECT DISTINCT column_name(s) FROM table_name SELECT INTO (used to create backup copies of tables) SELECT INTO new_table_name FROM original_table_nameor*SELECT column_name(s) INTO new_table_name FROM original_table_name TRUNCATE TABLE (deletes only the data inside the table) TRUNCATE TABLE table_name UPDATE UPDATE table_name SET column_name=new_value [, column_name=new_value] WHERE column_name=some_value WHERE SELECT column_name(s) FROM table_name WHERE condition 一个CASE的例子12345678910111213select Max(id) from apply_data as d;UPDATE apply_dataSET pingshen = case id%8 WHEN 0 THEN "253" WHEN 1 THEN "254" WHEN 2 THEN "255" WHEN 3 THEN "256" WHEN 4 THEN "257" WHEN 5 THEN "258" WHEN 6 THEN "259" WHEN 7 THEN "260" ENDWHERE id BETWEEN 1 and d]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用]]></title>
    <url>%2F2019%2F05%2F07%2FGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git使用Github建立私有项目并将本地项目文件上传首先在GitHub上建立私有项目 然后跳转到本地对应项目目录，输入： 1git init 生成git管理 之后输入： 1git add . 将文件夹中所有文件添加到仓库 之后输入： 1git commit -m "first commit" 表示此次git的注释 再输入： 1git remote add origin https://XXX.git 将本地仓库关联到Github上 最后输入： 1git push -u origin master 上传至Github仓库，根据提示输入用户名和密码 使用Github提交代码123456#Github提交代码git status #查看当前状态git add . #或者 git add xxx 添加到本地Git缓冲区git commit -m "message" #推送修改到本地git库中git pull &lt;远程主机名&gt; &lt;远程分支名&gt; #origin mastergit push &lt;远程主机名&gt; &lt;远程分支名&gt; 采用SSH方式连接Github123456789101112131415#采用SSH方式连接Github（默认为https需要每次输入用户名密码）#首先查看git当前连接方式git remote -v#然后移除git remote rm origin#添加ssh方式/git remote add origin git@github.com:username/yourrepo.gitgit push origin#生成SSH公钥,并复制ssh-keygen -t rsa -C "youremail"vi /root/.ssh/id_rsa.pub#到Github设置里找到相应的SSH&amp;GPG key添加 ssh公钥#再次查看 连接方式git remote -v .gitignore格式规范文件 .gitignore 的格式规范如下： 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反 ​ 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 12345678910111213# 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO# 忽略 build/ 目录下的所有文件build/# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录下所有扩展名为 txt 的文件doc/**/*.txt Git常用命令12345678910111213141516171819202122232425git clone &lt;address&gt;：复制代码库到本地；git add &lt;file&gt; ...：添加文件到代码库中；git rm &lt;file&gt; ...：删除代码库的文件；git commit -m &lt;message&gt;：提交更改，在修改了文件以后，使用这个命令提交修改。git pull：从远程同步代码库到本地。git push：推送代码到远程代码库。git branch：查看当前分支。带*是当前分支。git branch &lt;branch-name&gt;：新建一个分支。git branch -d &lt;branch-name&gt;：删除一个分支。git checkout &lt;branch-name&gt;：切换到指定分支。git log：查看提交记录（即历史的 commit 记录）。git status：当前修改的状态，是否修改了还没提交，或者那些文件未使用。git reset &lt;log&gt;：恢复到历史版本。 参考链接： https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基本操作]]></title>
    <url>%2F2019%2F04%2F15%2Fmysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[mysql基本操作安装123456789#在CentOS7.1安装mysqlwget https://repo.mysql.com/mysql57-community-release-el7.rpmsudo yum localinstall mysql57-community-release-el7.rpmyum repolist all | grep mysqlsudo yum-config-manager --enable mysql57-communitysudo yum install mysql-community-serversudo service mysqld startsudo chkconfig mysqld onmysql_secure_installation 基本使用123456789101112131415#mysql安装后的默认密码获取grep "temporary password" /var/log/mysqld.log#登陆之后在修改kRMx,HhtE5N!#启动mysqlservice mysqld startmysql -u root -pSET PASSWORD = PASSWORD('lns');#创建数据库，并导入文件create database lns;use lns;set names utf8;source /root/lns.sql; mysql导出数据库mysqldump -u用戶名 -p密码 -d 数据库名 表名 &gt; 脚本名; 1234567891011导出整个数据库结构和数据mysqldump -h localhost -uroot -p123456 database &gt; dump.sql导出单个数据表结构和数据mysqldump -h localhost -uroot -p123456 database table &gt; dump.sql导出整个数据库结构（不包含数据）mysqldump -h localhost -uroot -p123456 -d database &gt; dump.sql导出单个数据表结构（不包含数据）mysqldump -h localhost -uroot -p123456 -d database table &gt; dump.sql]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在PHP环境下安装Composer]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%9C%A8PHP%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Composer%2F</url>
    <content type="text"><![CDATA[在PHP环境下安装Composer 由于项目需要安装PHPOffice所以要先安装Composer 但是去官网试试下载了他的installer发现总是卡在最后一步 没办法只好再次百度，发现分为三步， 第一步. 修改php.exe同目录的php.ini，在里面搜索 ;extension=php_openssl.dll ，把前面的分号去掉。(这一步已经完成了) 第二步. 用如下三条命令安装Composer 123php -r "copy('https://install.phpcomposer.com/installer', 'composer-setup.php');"php composer-setup.phpphp -r "unlink('composer-setup.php');" 执行第一条命令下载下来的 composer-setup.php 脚本将简单地检测 php.ini 中的参数设置，如果某些参数未正确设置则会给出警告；然后下载最新版本的 composer.phar 文件到当前目录。 上述 3 条命令的作用依次是： 下载安装脚本 － composer-setup.php － 到当前目录。 执行安装过程。 删除安装脚本。 最后会下载一个composer.phar文件。 局部安装上述下载 Composer 的过程正确执行完毕后，可以将 composer.phar 文件复制到任意目录（比如项目根目录下），然后通过 php composer.phar 指令即可使用 Composer 了！ 全局安装全局安装是将 Composer 安装到系统环境变量 PATH 所包含的路径下面，然后就能够在命令行窗口中直接执行 composer 命令了。 Mac 或 Linux 系统：打开命令行窗口并执行如下命令将前面下载的 composer.phar 文件移动到 /usr/local/bin/ 目录下面： 复制 1sudo mv composer.phar /usr/local/bin/composer Windows 系统： 找到并进入 PHP 的安装目录（和你在命令行中执行的 php 指令应该是同一套 PHP）。 将 composer.phar 复制到 PHP 的安装目录下面，也就是和 php.exe在同一级目录。 在 PHP 安装目录下新建一个 composer.bat 文件，并将下列代码保存到此文件中。 复制 1@php "%~dp0composer.phar" %* 最后重新打开一个命令行窗口试一试执行 composer --version 看看是否正确输出版本号。 然而这是骗自己的。。。放到其他目录就不行了，不知道是不是没加进环境变量的原因，但是重跑一遍installer之后又能安装了，那就这样吧。 参考链接：https://pkg.phpcomposer.com/#how-to-install-composer https://docs.phpcomposer.com/00-intro.html 切换国内源： composer config -g repo.packagist composer https://packagist.phpcomposer.com 安装PHPWord composer require “phpoffice/phpword” composer install https://phpword.readthedocs.io/en/latest/installing.html#installation GitHub项目在这：https://github.com/PHPOffice/PHPWord 官方文档在这：http://phpword.readthedocs.io/en/latest/index.html 但是还是没法复制 问题待解决]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wamp64在不同的端口下部署多项目]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%9C%A8Windows%E7%9A%84Wamp64%E4%B8%8B%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%B8%8B%E9%83%A8%E7%BD%B2%E5%A4%9A%E9%A1%B9%E7%9B%AE%EF%BC%9A%2F</url>
    <content type="text"><![CDATA[在Windows的Wamp64下在不同的端口下部署多项目：首先打开注释： 12# Virtual hostsInclude conf/extra/httpd-vhosts.conf 修改C:\wamp64\bin\apache\apache2.4.37\conf\extra下的 httpd-vhosts.conf 12345678910111213141516171819202122232425262728293031323334# Virtual Hosts#&lt;VirtualHost *:80&gt; ServerName localhost ServerAlias localhost DocumentRoot &quot;$&#123;INSTALL_DIR&#125;/www&quot; &lt;Directory &quot;$&#123;INSTALL_DIR&#125;/www/&quot;&gt; Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require local &lt;/Directory&gt;&lt;/VirtualHost&gt;Listen 88&lt;VirtualHost *:88&gt; ServerName localhost DocumentRoot C:/wamp64/www/jsjxh/src &lt;Directory &quot;C:/wamp64/www/jsjxh/src&quot;&gt; Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require local &lt;/Directory&gt;&lt;/VirtualHost&gt;Listen 777&lt;VirtualHost *:777&gt; ServerName localhost DocumentRoot C:/wamp64/www/2017 &lt;Directory &quot;C:/wamp64/www/2017&quot;&gt; Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require local &lt;/Directory&gt;&lt;/VirtualHost&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客优化]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[博客优化hexo主题：https://www.zhihu.com/question/24422335 NexT主题下载：https://github.com/iissnan/hexo-theme-next/releases hexo官方文档：https://hexo.io/zh-cn/docs/tag-plugins NexT官方文档：http://theme-next.iissnan.com/getting-started.html MarkDown编辑器：Typora 主要思想就是有两个 _config.yml 一个是项目相关的，另外一个是主题的配置 要调整的要分清结构 调整字体大小： F:\blog\themes\next\source\css_variables下的base.styl 12345678910// Font size$font-size-base = 16px //修改以前是14，我改成了16$font-size-small = $font-size-base - 2px$font-size-smaller = $font-size-base - 4px$font-size-large = $font-size-base + 2px$font-size-larger = $font-size-base + 4px// Headings font size$font-size-headings-step = 2px$font-size-headings-base = 24px //这个是标题大小，如果你觉得不满意，可以改的更大一点 后续等待添加。。。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建流程]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[引言​ 今天心血来潮总算把自己的博客给搭建好了，其实这个想法早就有了，但是看着要不是用WordPress，还是Django之类的框架都比较麻烦，而且需要购买域名所以就一直没有认真去做。很多东西也只是用MarkDown写完放在本地，一直没有PO上网。 Jekyll + Github​ 这次主要是因为看见有一篇微博写了怎么利用Github写个人主页。 原文：https://towardsdatascience.com/how-to-create-a-free-github-pages-website-53743d7524e1 大略看了下，好像还涉及前端的知识，由于不是主攻方向，正准备放弃的时候，发现关键词 Jekyll ！于是把Jekyll + Github 百度一下： 官网：https://www.jekyll.com.cn/ 参考：https://blog.csdn.net/Hanghang_/article/details/78944672 发现流程主要是： 注册Github（这个基本可以略过） 选择主题 主题商店：http://jekyllthemes.org/ Fork 别人的项目，把名字修改成:{username}.github.io 用Git把项目下载到本地然后开始修改 开始写博客 非常凑巧的是他的博客也是用md格式转化而成的，本来这应该是个非常顺利的过程。但是问题出现在第二步，不知道为什么我选的那个主题的作者好像没公开他的源码，这就非常纠结了。其他的主题也不能说不行，就是不太合胃口，于是开始重新搜索，结果发现另外一种方式，Hexo + Github + NexT主题。 Hexo + Github + NexT主题一. 前期准备 注册Github，添加项目，项目名字格式{username}.github.io 安装Git和Node.js（地址就不放了） 安装Hexo，建立新文件夹放博客的文件，在该目录下右键点击Git Bash Here，打开git的控制台窗口。操作都在git控制台进行，（当然也可以用Windows自带的控制台） 定位到该目录下，输入npm install hexo-cli -g安装Hexo。会有几个报错，无视它就行。 然后输入npm install hexo --save继续安装。 安装完后输入hexo -v验证是否安装成功。 输入hexo init初始化文件夹，接着输入npm install安装必备的组件。 这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开[http://localhost:4000/] 默认是4000 也可以用-p 来指定端口。 演示效果如上图（自己的忘存了。。。），我自己在这里碰见N次502 错误，最后才发现是SSR没关导致的，最后改成直连就能显示了。 最后按ctrl+c关闭本地服务器。 二. 配置Git ssh1. 设置Git的user name和email12git config --global user.name "&#123;username&#125;"git config --global user.email "&#123;emailaddr&#125;" 2. 检查是否已经有SSH Key12cd ~/.sshls 列出文件看看是否有 id_isa 和 id_isa.pub 文件 如果有可以跳过生成密钥这一阶段 生成密钥 1ssh-keygen -t rsa -C "&#123;email&#125;" ​ 如果不需要密码的话，连续3个回车。最后得到了两个文件：id_rsa和id_rsa.pub。 默认的存储路径是： 1C:\Users\&#123;UserName&#125;\.ssh 4. 添加密钥到ssh-agent​ 确保 ssh-agent 是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器， ​ 运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。 12# start the ssh-agent in the backgroundeval "$(ssh-agent -s)" ​ 添加生成的 SSH key 到 ssh-agent。 1ssh-add ~/.ssh/id_rsa 5. 登陆Github, 添加 ssh​ 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。 ​ 打开C:\Users\{UserName}\.ssh\id_rsa.pub，注意是隐藏文件夹，将其中的内容复制到新建的SSH中。 ​ 输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。 ​ 打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。 ​ 修改最后一行的配置： 1234deploy: type: git repository: https://github.com/&#123;username&#125;/&#123;username&#125;.github.io branch: master repository修改为你自己的github项目地址。 三.文章相关操作写文章、发布文章​ 首先在博客根目录下右键打开git，安装一个扩展npm install hexo-deployer-git --save。 ​ 然后输入hexo new post &quot;article title&quot;，新建一篇文章。 ​ 然后打开博客目录下的\source\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。 ​ 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章。 ​ 当然这一步也可以用之前写好的md文件放进去加一个Yaml格式的头在最前面里面写上标题，创建时间，等相关信息也是可以自动生成的。 ​ 至于其他的比如换主题之类的就留到下一篇吧。这个基本上把博客给搭建完了。 参考1：https://blog.csdn.net/gdutxiaoxu/article/details/53573399 参考2：https://zhuanlan.zhihu.com/p/35668237 hexo中文官网：https://hexo.io/zh-cn/docs/]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>Just For Remember</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基本知识（3）]]></title>
    <url>%2F2019%2F04%2F03%2FJava-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java 基本知识（3）十二、封装的作用和意义需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。说的专业一点，封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 123我们程序设计要追求“高内聚，低耦合”。 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。 编程中封装的具体优点 提高代码的安全性。 提高代码的复用性。 “高内聚”：封装细节，便于修改内部代码，提高可维护性。 “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。 封装的实现—使用访问控制符 Java是使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露的。 Java中4种“访问控制符”分别为private、default、protected、public，它们说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性。 表 访问权限修饰符 private 表示私有，只有自己类能访问 default表示没有修饰符修饰，只有同一个包的类能访问 protected表示可以被同一个包的类以及其他包中的子类访问 public表示可以被该项目的所有包中的所有类访问 下面做进一步说明Java中4种访问权限修饰符的区别：首先我们创建4个类：Person类、Student类、Animal类和Computer类，分别比较本类、本包、子类、其他包的区别。 类的属性的处理 一般使用private访问权限。 提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 十三、多态多态的要点 多态是方法的多态，不是属性的多态(多态与属性无关)。 多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了 十四、变量的转型 父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。 向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型! 十五、final关键字的作用修饰变量被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。 1final int MAX_SPEED = 120; 修饰方法该方法不可被子类重写。但是可以被重载! 123final void study()&#123; &#125; 修饰类修饰的类不能被继承。比如：Math、String等。 123final class A &#123; &#125; 十六、抽象方法抽象类抽象方法使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。 抽象类包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 【示例】抽象类和抽象方法的基本用法 123456789101112131415161718192021//抽象类abstract class Animal &#123; abstract public void shout(); //抽象方法&#125;class Dog extends Animal &#123; //子类必须实现父类的抽象方法，否则编译错误 public void shout() &#123; System.out.println("汪汪汪！"); &#125; public void seeDoor()&#123; System.out.println("看门中...."); &#125;&#125;//测试抽象类public class TestAbstractClass &#123; public static void main(String[] args) &#123; Dog a = new Dog(); a.shout(); a.seeDoor(); &#125;&#125; 抽象类的使用要点 有抽象方法的类只能定义成抽象类 抽象类不能实例化，即不能用new来实例化抽象类。 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 抽象类只能用来被继承。 抽象方法必须被子类实现。 十七、接口的定义和使用声明格式1234[访问修饰符] interface 接口名 [extends 父接口1，父接口2…] &#123; 常量定义； 方法定义；&#125; 定义接口的详细说明 访问修饰符：只能是public或默认。 接口名：和类名采用相同命名机制。 extends：接口可以多继承。 常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。 方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。 要点 子类通过implements来实现接口中的规范。 接口不能创建实例，但是可用于声明引用变量类型。 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。 JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。 JDK1.8后，接口中包含普通的静态方法。 接口的使用1234567891011121314151617181920212223242526272829303132333435363738public class TestInterface &#123; public static void main(String[] args) &#123; Volant volant = new Angel(); volant.fly(); System.out.println(Volant.FLY_HIGHT); Honest honest = new GoodMan(); honest.helpOther(); &#125;&#125;/**飞行接口*/interface Volant &#123; int FLY_HIGHT = 100; // 总是：public static final类型的； void fly(); //总是：public abstract void fly();&#125;/**善良接口*/interface Honest &#123; void helpOther();&#125;/**Angle类实现飞行接口和善良接口*/class Angel implements Volant, Honest&#123; public void fly() &#123; System.out.println("我是天使，飞起来啦！"); &#125; public void helpOther() &#123; System.out.println("扶老奶奶过马路！"); &#125;&#125;class GoodMan implements Honest &#123; public void helpOther() &#123; System.out.println("扶老奶奶过马路！"); &#125; &#125;class BirdMan implements Volant &#123; public void fly() &#123; System.out.println("我是鸟人，正在飞！"); &#125;&#125; 接口支持多继承，和类的继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切。 接口的多继承123456789101112131415161718interface A &#123; void testa();&#125;interface B &#123; void testb();&#125;/**接口可以多继承：接口C继承接口A和B*/interface C extends A, B &#123; void testc();&#125;public class Test implements C &#123; public void testc() &#123; &#125; public void testa() &#123; &#125; public void testb() &#123; &#125;&#125; 十八、内部类内部类的概念 一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(inner classes)。 内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰。 注意内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同。 内部类介绍123456789101112131415/**外部类Outer*/class Outer &#123; private int age = 10; public void show()&#123; System.out.println(age);//10 &#125; /**内部类Inner*/ public class Inner &#123; //内部类中可以声明与外部类同名的属性与方法 private int age = 20; public void show()&#123; System.out.println(age);//20 &#125; &#125;&#125; 内部类的作用 内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。 内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。 接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。 内部类的使用场合 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。 使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。 内部类的分类 在Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。 成员内部类(可以使用private、default、protected、public任意进行修饰。 类文件：外部类$内部类.class) a) 非静态内部类外部类里使用非静态内部类和平时使用其他类没什么不同 i. 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。 ii. 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。 iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。 iv. 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。 v. 成员变量访问要点： 内部类里方法的局部变量：变量名。 内部类属性：this.变量名。 外部类属性：外部类名.this.变量名。 【举例】123456789101112class Outer &#123; private int age = 10; class Inner &#123; int age = 20; public void show() &#123; int age = 30; System.out.println("内部类方法里的局部变量age:" + age);// 30 System.out.println("内部类的成员变量age:" + this.age);// 20 System.out.println("外部类的成员变量age:" + Outer.this.age);// 10 &#125; &#125;&#125; vi. 内部类的访问： 外部类中定义内部类： 1new Inner() 外部类以外的地方使用非静态内部类： 1Outer.Inner varname = new Outer().new Inner()。 内部类的访问 12345678910public class TestInnerClass &#123; public static void main(String[] args) &#123; //先创建外部类实例，然后使用该外部类实例创建内部类实例 Outer.Inner inner = new Outer().new Inner(); inner.show(); Outer outer = new Outer(); Outer.Inner inn = outer.new Inner(); inn.show(); &#125;&#125; b) 静态内部类i. 定义方式：123static class ClassName &#123;//类体&#125; ii. 使用要点：1231. 当一个静态内部类对象存在，并不一定存在对应的外部类对象。 因此，静态内部类的实例方法不能直接访问外部类的实例方法。2. 静态内部类看做外部类的一个静态成员。 因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过 new 静态内部类()访问静态内部类的实例。 静态内部类的访问123456789101112class Outer&#123; //相当于外部类的一个静态成员 static class Inner&#123; &#125;&#125;public class TestStaticInnerClass &#123; public static void main(String[] args) &#123; //通过 new 外部类名.内部类名() 来创建内部类对象 Outer.Inner inner =new Outer.Inner(); //Outer.Inner inner = new Outer().new Inner(); 非静态内部类 &#125;&#125; 匿名内部类1适合那种只需要使用一次的类。比如：键盘监听操作等等。 语法123new 父类构造器(实参类表) \实现接口 () &#123; //匿名内部类类体！&#125; 匿名内部类的使用123456789101112131415161718this.addWindowListener(new WindowAdapter()&#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;);this.addKeyListener(new KeyAdapter()&#123; @Override public void keyPressed(KeyEvent e) &#123; myTank.keyPressed(e); &#125; @Override public void keyReleased(KeyEvent e) &#123; myTank.keyReleased(e); &#125; &#125;); 注意 匿名内部类没有访问修饰符。 匿名内部类没有构造方法。因为它连名字都没有那又何来构造方法呢。 局部内部类还有一种内部类，它是定义在方法内部的，作用域只限于本方法，称为局部内部类。 局部内部类的的使用主要是用来解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类。局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法中被使用，出了该方法就会失效。 局部内部类在实际开发中应用很少。 方法中的内部类1234567891011121314public class Test2 &#123; public void show() &#123; //作用域仅限于该方法 class Inner &#123; public void fun() &#123; System.out.println("helloworld"); &#125; &#125; new Inner().fun(); &#125; public static void main(String[] args) &#123; new Test2().show(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基本知识（2）]]></title>
    <url>%2F2019%2F04%2F03%2FJava-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java 基本知识（2）七、this关键字对象创建的过程和this的本质 构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步： 分配对象空间，并将对象成员变量初始化为0或空 执行属性值的显示初始化 执行构造方法 返回对象的地址给相关的变量 this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。 this最常的用法 在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。 this不能用于static方法中。 this代表“当前对象”示例1234567891011121314151617181920`public class User &#123; int id; //id String name; //账户名 String pwd; //密码 public User() &#123; &#125; public User(int id, String name) &#123; System.out.println("正在初始化已经创建好的对象："+this); this.id = id; //不写this，无法区分局部变量id和成员变量id this.name = name; &#125; public void login()&#123; System.out.println(this.name+",要登录！"); //不写this效果一样 &#125; public static void main(String[] args) &#123; User u3 = new User(101,"高小七"); System.out.println("打印高小七对象："+u3); u3.login(); &#125; &#125; 运行结果如图所示。 this()调用重载构造方法1234567891011121314151617181920212223242526272829public class TestThis &#123; int a, b, c; TestThis() &#123; System.out.println("正要初始化一个Hello对象"); &#125; TestThis(int a, int b) &#123; // TestThis(); //这样是无法调用构造方法的！ this(); // 调用无参的构造方法，并且必须位于第一行！ a = a;// 这里都是指的局部变量而不是成员变量 // 这样就区分了成员变量和局部变量. 这种情况占了this使用情况大多数 this.a = a; this.b = b; &#125; TestThis(int a, int b, int c) &#123; this(a, b); // 调用带参的构造方法，并且必须位于第一行！ this.c = c; &#125; void sing() &#123; &#125; void eat() &#123; this.sing(); // 调用本类中的sing(); System.out.println("你妈妈喊你回家吃饭！"); &#125; public static void main(String[] args) &#123; TestThis hi = new TestThis(2, 3); hi.eat(); &#125;&#125; 八、static关键字特点在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点： 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!! 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。) 在static方法中不可直接访问非static的成员。 核心要点： static修饰的成员变量和方法，从属于类。 普通变量和方法从属于对象的。 12345678910111213141516171819202122232425262728293031public class User2 &#123; int id; // id String name; // 账户名 String pwd; // 密码 static String company = "北京尚学堂"; // 公司名称 public User2(int id, String name) &#123; this.id = id; this.name = name; &#125; public void login() &#123; printCompany(); System.out.println(company); System.out.println("登录：" + name); &#125; public static void printCompany() &#123;// login();//调用非静态成员，编译就会报错 System.out.println(company); &#125; public static void main(String[] args) &#123; User2 u = new User2(101, "高小七"); User2.printCompany(); User2.company = "北京阿里爷爷"; User2.printCompany(); &#125;&#125; 静态初始化块构造方法用于对象的初始化!静态初始化块，用于类的初始化操作!在静态初始化块中不能直接访问非static成员。 注意事项： 静态初始化块执行顺序： 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。 构造方法执行顺序和上面顺序一样!! static初始化块 1234567891011121314151617public class User3 &#123; int id; //id String name; //账户名 String pwd; //密码 static String company; //公司名称 static &#123; System.out.println("执行类的初始化工作"); company = "北京尚学堂"; printCompany(); &#125; public static void printCompany()&#123; System.out.println(company); &#125; public static void main(String[] args) &#123; User3 u3 = new User3(); &#125;&#125; 九、参数传值机制 Java中，方法中所有参数都是“值传递”，也就是“传递的是值的副本”。 也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件改变不会影响原件。 基本数据类型参数的传值 传递的是值的副本。 副本改变不会影响原件。 引用类型参数的传值 传递的是值的副本。但是引用类型指的是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”。 多个变量指向同一个对象1234567891011121314151617181920212223242526public class User4 &#123; int id; //id String name; //账户名 String pwd; //密码 public User4(int id, String name) &#123; this.id = id; this.name = name; &#125; public void testParameterTransfer01(User4 u)&#123; u.name="高小八"; &#125; public void testParameterTransfer02(User4 u)&#123; u = new User4(200,"高三"); &#125; public static void main(String[] args) &#123; User4 u1 = new User4(100, "高小七"); u1.testParameterTransfer01(u1); System.out.println(u1.name); u1.testParameterTransfer02(u1); System.out.println(u1.name); 十、包包机制是Java中管理类的重要手段。 开发中，我们会遇到大量同名的类，通过包我们很容易对解决类重名的问题，也可以实现对类的有效管理。 包对于类，相当于文件夹对于文件的作用。 包的使用我们通过package实现对类的管理，package的使用有两个要点： 通常是类的第一句非注释性语句。 包名：域名倒着写即可，再加上模块名，便于内部管理类。 【示例】 package的命名举例 12345com.sun.test;com.oracle.test;cn.sxt.yuan.test;cn.sxt.yuan.view;cn.sxt.yuan.view.model; 注意事项： 写项目时都要加包，不要使用默认包。 com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分。 【示例】package的使用 123456package cn.yuan;public class Test &#123; public static void main(String[] args) &#123; System.out.println("helloworld"); &#125;&#125; Java中常用包 Java中的常用包 说明 java.lang 包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。 java.awt 包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 java.net 包含执行与网络相关的操作的类。 java.io 包含能提供多种输入/输出功能的类。 java.util 包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。 如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性。 注意要点： Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。 如果导入两个同名的类，只能用包名+类名来显示调用相关类： 1java.util.Date date = new java.util.Date(); 【示例】1234567891011121314import java.sql.Date;import java.util.*;//导入该包下所有的类。会降低编译速度，但不会降低运行速度。 public class Test&#123; public static void main(String[] args) &#123; //这里指的是java.sql.Date Date now; //java.util.Date因为和java.sql.Date类同名，需要完整路径 java.util.Date now2 = new java.util.Date(); System.out.println(now2); //java.util包的非同名类不需要完整路径 Scanner input = new Scanner(System.in); &#125;&#125; 十一、继承继承的实现1234567891011121314151617181920212223242526public class Test&#123; public static void main(String[] args) &#123; Student s = new Student("高淇",172,"Java"); s.rest(); s.study(); &#125;&#125;class Person &#123; String name; int height; public void rest()&#123; System.out.println("休息一会！"); &#125; &#125;class Student extends Person &#123; String major; //专业 public void study()&#123; System.out.println("在尚学堂，学习Java"); &#125; public Student(String name,int height,String major) &#123; //天然拥有父类的属性 this.name = name; this.height = height; this.major = major; &#125;&#125; 继承的使用要点1.父类也称作超类、基类等。 2.Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。 3.Java中类没有多继承，接口有多继承。 4.子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。 5.如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。 方法的重写override方法重写的三个要点123451.“==”： 方法名、形参列表相同。2.“≤”：返回值类型和声明异常类型，子类小于等于父类。3.“≥”： 访问权限，子类大于等于父类。 【示例】方法重写1234567891011121314151617181920212223242526272829303132333435public class TestOverride &#123; public static void main(String[] args) &#123; Vehicle v1 = new Vehicle(); Vehicle v2 = new Horse(); Vehicle v3 = new Plane(); v1.run(); v2.run(); v3.run(); v2.stop(); v3.stop(); &#125;&#125; class Vehicle &#123; // 交通工具类 public void run() &#123; System.out.println("跑...."); &#125; public void stop() &#123; System.out.println("停止不动"); &#125;&#125;class Horse extends Vehicle &#123; // 马也是交通工具 public void run() &#123; // 重写父类方法 System.out.println("四蹄翻飞，嘚嘚嘚..."); &#125;&#125; class Plane extends Vehicle &#123; public void run() &#123; // 重写父类方法 System.out.println("天上飞！"); &#125; public void stop() &#123; System.out.println("空中不能停，坠毁了！"); &#125;&#125; super关键字 super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。 123使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。若是构造方法的第一行代码没有显式的调用super(...)或者this(...);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。 super关键字的使用12345678910111213141516171819202122public class TestSuper01 &#123; public static void main(String[] args) &#123; new ChildClass().f(); &#125;&#125;class FatherClass &#123; public int value; public void f()&#123; value = 100; System.out.println ("FatherClass.value="+value); &#125;&#125;class ChildClass extends FatherClass &#123; public int value; public void f() &#123; super.f(); //调用父类对象的普通方法 value = 200; System.out.println("ChildClass.value="+value); System.out.println(value); System.out.println(super.value); //调用父类对象的成员变量 &#125;&#125; 继承树追溯属性/方法查找顺序：(比如：查找变量h)12345671. 查找当前类中有没有属性h2. 依次上溯每个父类，查看每个父类中是否有h，直到Object3. 如果没找到，则出现编译错误。4. 上面步骤，只要找到h变量，则这个过程终止。 构造方法调用顺序构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。 注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复。 构造方法向上追溯执行测试12345678910111213141516public class TestSuper02 &#123; public static void main(String[] args) &#123; System.out.println("开始创建一个ChildClass对象......"); new ChildClass(); &#125;&#125;class FatherClass &#123; public FatherClass() &#123; System.out.println("创建FatherClass"); &#125;&#125;class ChildClass extends FatherClass &#123; public ChildClass() &#123; System.out.println("创建ChildClass"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基本知识（1）]]></title>
    <url>%2F2019%2F04%2F03%2FJava-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java 基本知识（1）一、数据类型Java支持的类型分为两类：基本类型和引用类型 1.基本类型4类8种： （1）整型:int、short、long、byte。 （2）浮点型:float、double。 （3）字符型：char。 （4）布尔型：boolean。 2.引用类型引用类型包括类、接口、枚举和数组类型、null类型。 空引用null只能被被转化为引用类型，不能转化成基本类型，因此，不能把一个null值赋给基本类型的变量。 备注：（1）字符串类型是一个类，即引用类型 二、循环用法if的用法123456789if(statement)&#123; &#125;else if()&#123; &#125;else &#123; &#125; switch的用法12345678910switch (表达式) &#123; case 值1: 语句序列1; [break]; case 值2: 语句序列2; [break]; … … … … … [default:默认语句;] &#125; while和for的用法12345678while(statement)&#123; &#125;for (初始表达式; 布尔表达式; 迭代因子) &#123; 循环体; &#125; 三、重载构成方法重载的条件： 1.不同的含义：形参类型、形参个数、形参顺序不同 2.只有返回值不同不构成方法的重载 3.只有形参的名称不同，不构成方法的重载 四、面向对象和面向过程的总结 1、都是解决问题的思维方式，都是代码组织的方式。 2、解决简单问题可以使用面向过程 3、解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。 面向对象思考方式 遇到复杂问题，先从问题中找名词，然后确立这些名词哪些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。 建议 1.面向对象具有三大特征：封装性、继承性和多态性，而面向过程没有继承性和多态性，并且面向过程的封装只是封装功能，而面向对象可以封装数据和功能。所以面向对象优势更明显。 2.一个经典的比喻：面向对象是盖浇饭、面向过程是蛋炒饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。 五、栈与堆栈的特点 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 栈属于线程私有，不能实现线程间的共享! 栈的存储特性是“先进后出，后进先出” 栈是由系统自动分配，速度快!栈是一个连续的内存空间! 堆的特点 堆用于存储创建好的对象和数组(数组也是对象) JVM只有一个堆，被所有线程共享 堆是一个不连续的内存空间，分配灵活，速度慢! 方法区(又叫静态区)特点 JVM只有一个方法区，被所有线程共享! 方法区实际也是堆，只是用于存储类、常量相关的信息! 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等) 通过new关键字调用!! 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加! 构造器的方法名必须和类名一致! 六、内存管理与GC内存管理 Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。 对象空间的分配：使用new关键字创建对象即可 对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。 垃圾回收过程任何一种垃圾回收算法一般要做两件基本事情： 发现无用的对象 回收无用对象占用的内存空间。 垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的就是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。 垃圾回收相关算法引用计数法 堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。 【示例4-7】循环引用示例 123456789101112public class Student &#123; String name; Student friend; public static void main(String[] args) &#123; Student s1 = new Student(); Student s2 = new Student(); s1.friend = s2; s2.friend = s1; s1 = null; s2 = null; &#125;&#125; s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。 引用可达法(根搜索算法) 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 分代垃圾回收机制分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。 年轻代 所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。 年老代 在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。 持久代 用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。 垃圾回收方案Minor GC: 用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空) Major GC： 用于清理老年代区域。 Full GC： 用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。 垃圾回收过程1、新创建的对象，绝大多数都会存储在Eden中， 2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区 3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。 4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中， 5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC） 在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC： 1.年老代(Tenured)被写满 2.持久代(Perm)被写满 3.System.gc()被显式调用（程序建议GC启动，不是调用GC） 4.上一次GC之后Heap的各域分配策略动态变化]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
